/****************************************************************************/
/* This file is part of Davor Penzar's master thesis programing.            */
/*                                                                          */
/* The file is intended to be included at the end of a file defining the    */
/* border and the mesh.  The border must be labeled as 0 and and the mesh   */
/* must be named `Th`.                                                      */
/*                                                                          */
/* When run, the code computes the first eigenvalue of the Laplace operator */
/* on the given domain and prints it to a file.  The name of the file is    */
/* given via the first command line argument after the name of the main     */
/* script, but the extension ".txt" is appended to it (if the given file    */
/* name is "out.txt", the resulting file will be "out.txt.txt"; to print to */
/* a file named "out.txt", the given file name must be only "out").         */
/*                                                                          */
/* The code is inspired by the example of the solution of the Laplace       */
/* eigenvalue problem given at                                              */
/* https://doc.freefem.org/models/eigen-value-problems.html                 */
/****************************************************************************/

// Define the global parameters.
//verbosity = 0;
int nev = 20;   // Number of eigenvalues to compute.

// Build the finite element space.
fespace Vh(Th, P2); // P2 conforming triangular finite element space.
Vh u1, u2;

// Define the label of the border.
int GammaLabel = 0;

// Define the problem.
varf a (u1, u2) =
    int2d(Th)(dx(u1) * dx(u2) + dy(u1) * dy(u2)) + on(GammaLabel, u1 = 0);
varf b (u1, u2) = int2d(Th)(u1 * u2);   // No boundary condition.

// Construct the matrices.
matrix A = a(Vh, Vh, solver = Crout, factorize = 1);
matrix B = b(Vh, Vh, solver = CG, eps = 1e-20);

// Construct the arrays for the solution.
real[int] ev(nev);  // To store the `nev` eigenvalues.
Vh[int] eV(nev);    // To store the `nev` eigenvectors.

// Solve the problem.
int k = EigenValue(
    A,
    B,
    sym = true,
    value = ev,
    vector = eV,
    tol = 1e-10,
    maxit = 0,
    ncv = 0
);

// Display and plot the solution.  The eigenvalues and the eigenvectors are
// indexed starting from 0.
for (int i = 0; i < k; ++i)
{
    u1 = eV[i];
    cout <<
        "lambda[" << i << "] = " << ev[i] <<
        ", " <<
        "err = " <<
            abs(
                int2d(Th)(
                    dx(u1) * dx(u1) + dy(u1) * dy(u1) - ev[i] * u1 * u1
                )
            ) <<
        endl;
    plot(
        eV[i],
        cmm = "Eigenvector " + i + ", eigenvalue = " + ev[i],
        wait = true,
        value = true
    );
}

/*
// Print the first eigenvalue to the file.
{
    // Open the file.
    ofstream out(ARGV[2] + ".txt");

    // Set the precision.
    out.precision(8);

    // Print the first eigenvalue.
    out << ev[0] << endl;
}
*/

/****************************************************************************/
/* This file is part of Davor Penzar's master thesis programing.            */
/*                                                                          */
/* Usage:                                                                   */
/*     $ FreeFem++ computer3.edp [-i filein] [-o fileout]                   */
/* Arguments:                                                               */
/*     -i: [filename]  path to the input file (default: "in.tsv")           */
/*     -o: [filename]  path to the output file (default: "out.csv")         */
/* Other arguments are ignored.                                             */
/*                                                                          */
/* Consider an open nonempty set $ \Omega \subseteq \mathbb{R}^{2} $ such   */
/* that its boundary $ \partial \Omega $ is piecewise smooth.  A value      */
/* $ \lambda \in \mathbb{R}^{2} $ is called the EIGENVALUE OF THE LAPLACE   */
/* OPERATOR (ON $ \OMEGA $) if there exists a continuous nonconstant        */
/* function $ u \colon \overline{\Omega} \to \mathbb{R}^{2} $ twice         */
/* differential on $ \Omega $ such that                                     */
/*     $ \Delta u = \lambda u $ on $ \Omega $,                              */
/*     $ u = 0 $ on $ \partial \Omega $,                                    */
/* where $ \Delta $ denotes the Laplace operator (sum of all second partial */
/* derivatives)---the function $ u $ is then called the EIGENFUNCTION OF    */
/* THE LAPLACE OPERATOR (ON $ \Omega $).  If $ \Omega $ is bounded, these   */
/* eigenvalues and eigenfunctions exist, for each eigenvalue there are      */
/* finitely many lineary independent eigenfunctions, and there are          */
/* countably infinitely many eigenvalues all of which are strictly positive */
/* with no accumulation point.                                              */
/*                                                                          */
/* The script reads definitions of polygons and prints the numerical        */
/* approximations of the first eigenvalues of the Laplace operator on the   */
/* polygons.                                                                */
/*                                                                          */
/* Each polygon must be formated in the input file as                       */
/*     x0 y0 lx0 ly0 nm0 x1 y1 lx1 ly1 nm1 ... xn yn lxn lyn nmn            */
/* where:                                                                   */
/*     n + 1   is the number of vertices,                                   */
/*     xi  is the x-coordinate of the i-th vertex,                          */
/*     yi  is the y-coordinate of the i-th vertex,                          */
/*     lxi is the difference in x-coordinates of the                        */
/*         ((i + 1) mod n + 1)-th vertex and the i-th vertex,               */
/*     lyi is the difference in y-coordinates of the                        */
/*         ((i + 1) mod n + 1)-th vertex and the i-th vertex,               */
/*     nmi is the number of mesh points to generate on the edge spanning    */
/*         from the ((i + 1) mod n + 1)-th vertex to the i-th vertex.       */
/* Whitespaces may differ (they may even be spaces, tabs, newlines...).     */
/* All of the polygons must have the same number of vertices; moreover, the */
/* number is hard coded in the script.  To change the number of vertices,   */
/* update the global parameter `np`, the definition of the border, the      */
/* plotting of the border and the definition of the mesh.                   */
/*                                                                          */
/* Eigenvalues are printed to the output file in the same order as the      */
/* polygons were defined in the input file, separated by a comma (no        */
/* whitespace).  An extra new line (empty) is added at the end of the       */
/* output file.  The precision of the output is hard coded in the script    */
/* (global parameter `prec`).                                               */
/*                                                                          */
/* The current number of vertices is 3 (hence the name of the script        */
/* "computer3.edp").                                                        */
/*                                                                          */
/* The code is inspired by the example of the solution of the Laplace       */
/* eigenvalue problem given at                                              */
/* https://doc.freefem.org/models/eigen-value-problems.html                 */
/****************************************************************************/

// Include the getARGV header.
include "getARGV.idp"

// Define the global parameters.
verbosity = 0;      // Verbosity level 0.
int prec = 8;       // Precision of the output.
real tol = 1.0e-12; // Tolerance for the solution.
real eps = 1.0e-24; // Epsilon for the CG solver.
int np = 1;         // Number of polygons.
int nv = 3;         // Number of vertices (change code acccordingly).
int nev = 1;        // Number of eigenvalues to compute.

// Declare input/output arrays.
real[int, int] Px(np, nv);  // x-coordinates of vertices.
real[int, int] Py(np, nv);  // y-coordinates of vertices.
real[int, int] lx(np, nv);  // Differences in x-coordinates of vertices.
real[int, int] ly(np, nv);  // Differences in y-coordinates of vertices.
real[int, int] nm(np, nv);  // Numbers of mesh points on edges.
real[int] ev0(np);          // The first eigenvalues.

// Declare variables to store time.
real t0 = 0.0;
real t1 = 0.0;

// Read the input.
{
    // Open the input file.
    ifstream in(getARGV("-i", "in.tsv"));

    // Get time in seconds.
    t0 = clock();

    // Read from the input file.
    for (int i = 0; i < np; ++i)
        for (int j = 0; j < nv; ++j)
            in >> Px(i, j) >> Py(i, j) >> lx(i, j) >> ly(i, j) >> nm(i, j);

    // Get time in seconds.
    t1 = clock();

    // Print elapsed time.
    cout << "Reading: " << (t1 - t0) << "s." << endl;
}

// Get time in seconds.
t0 = clock();

// Compute the eigenvalues.
for (int i = 0; i < np; ++i)
{
    // Define the border.
    border Gamma0 (t = 0.0, 1.0)
    {
        x = Px(i, 0) + lx(i, 0) * t;
        y = Py(i, 0) + ly(i, 0) * t;
        label = i;
    }
    border Gamma1 (t = 0.0, 1.0)
    {
        x = Px(i, 1) + lx(i, 1) * t;
        y = Py(i, 1) + ly(i, 1) * t;
        label = i;
    }
    border Gamma2 (t = 0.0, 1.0)
    {
        x = Px(i, 2) + lx(i, 2) * t;
        y = Py(i, 2) + ly(i, 2) * t;
        label = i;
    }

//  // Plot the border.
//  plot(
//      Gamma0(nm(i, 0)) +
//      Gamma1(nm(i, 1)) +
//      Gamma2(nm(i, 2)),
//      cmm = "Polygon " + i + ": Border",
//      wait = true
//  );

    // Build the mesh.
    mesh Th = buildmesh(
        Gamma0(nm(i, 0)) +
        Gamma1(nm(i, 1)) +
        Gamma2(nm(i, 2))
    );

//  // Plot the mesh.
//  plot(
//      Th,
//      cmm = "Polygon " + i + ": Mesh",
//      wait = true
//  );

    // Build the finite element space.
    fespace Vh(Th, P2); // P2 conforming triangular finite element space.
    Vh u1;
    Vh u2;

    // Define the problem.
    varf a (u1, u2) =
        int2d(Th)(dx(u1) * dx(u2) + dy(u1) * dy(u2)) +
        on(i, u1 = 0);                      // With boundary condition.
    varf b (u1, u2) = int2d(Th)(u1 * u2);   // No boundary condition.

    // Construct the matrices for the problem.
    matrix A = a(Vh, Vh, solver = Crout, factorize = 1);
    matrix B = b(Vh, Vh, solver = CG, eps = eps);

    // Construct the arrays for the solution.
    real[int] ev(nev);  // To store the `nev` eigenvalues.
    Vh[int] eV(nev);    // To store the `nev` eigenvectors (eigenfunctions).

    // Solve the problem.
    int k = EigenValue(
        A,
        B,
        nev = nev,
        sym = true,
        value = ev,
        vector = eV,
        tol = tol,
        sigma = 0.0,
        maxit = 0,
        ncv = 0
    );

//  // Display and plot the solution.  The eigenvalues and the eigenvectors
//  // (eigenfunctions) are indexed starting from 0.
//  cout << "Polygon " << i << ":" << endl;
//  for (int j = 0; j < k; ++j)
//  {
//      // Extract the eigenvector
//      u1 = eV[j];
//
//      // Display the eigenvalue.
//      cout <<
//          "\tlambda[" << j << "] = " << ev[j] <<
//          ", " <<
//          "err = " <<
//              abs(
//                  int2d(Th)(
//                      dx(u1) * dx(u1) +
//                      dy(u1) * dy(u1) -
//                      ev[j] * u1 * u1
//                  )
//              ) <<
//          endl;
//
//      // Plot the eigenvector (eigenfunction).
//      plot(
//          eV[j],
//          cmm =
//              "Polygon " + i + ":" +
//              " " +
//              "eigenvector " + j +
//              ", " +
//              "eigenvalue = " + ev[j],
//          value = true,
//          wait = true
//      );
//  }

    // Save the first eigenvalue.
    ev0[i] = (k > 0) ? ev[0] : 0.0;
}

// Get time in seconds.
t1 = clock();

// Print elapsed time.
cout << "Computing: " << (t1 - t0) << "s." << endl;

// Print the output.
{
    // Open the output file.
    ofstream out(getARGV("-o", "out.csv"));

    // Set the precision of the output.
    out.fixed;
    out.precision(prec);

    // Get time in seconds.
    t0 = clock();

    // Print to the output file.
    if (np > 0)
    {
        out << ev0[0];
        for (int i = 1; i < np; ++i)
            out << "," << ev0[i];
        out << endl;
    }

    // Get time in seconds.
    t1 = clock();

    // Print elapsed time.
    cout << "Printing: " << (t1 - t0) << "s." << endl;
}

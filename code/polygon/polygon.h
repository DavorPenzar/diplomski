/**
 * Functions for generating and checking polygons.
 *
 * @author Davor Penzar <davor.penzar@gmail.com>
 * @version 1.0
 * @package polygon
 *
 */

/* Check if the header has already been imported. */
#if !(defined(__POLYGON_H__INCLUDED) && (__POLYGON_H__INCLUDED) == 1)

/* Undefine __POLYGON_H__INCLUDED if it has already been defined. */
#if defined(__POLYGON_H__INCLUDED)
#undef __POLYGON_H__INCLUDED
#endif /* __POLYGON_H__INCLUDED */

/* Define __POLYGON_H__INCLUDED as 1. */
#define __POLYGON_H__INCLUDED 1

/* Import standard library headers. */

#if !defined(__cplusplus)

#include <math.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#else

#include <cmath>
#include <cstddef>
#include <cstdlib>
#include <cstring>

#include <exception>
#include <memory>
#include <new>
#include <stdexcept>

#endif /* __cplusplus */

/* Import package headers. */
#include "array.h"
#include "boolean.h"
#include "numeric.h"

/**
 * Generate points in a plane.
 *
 * Use this function to generate a polygon if it is likely (or even certain)
 * that the generated array of points will be a polygon (if additional checkings
 * during the generating process is unnecessary) using the `generator` function.
 * Otherwise use the `smart_random_polygon` function.
 *
 * Caution: the function may fail if memory must be allocated for the resulting
 * array, but the allocation failed.  If that happens, the null-pointer is
 * returned.  Exceptions thrown by failed memory allocation in C++ are not
 * caught.
 *
 * @param n
 *     Number of points to generate.
 *
 * @param P
 *     Pointer to the coordinates of the first point in the array of size at
 *     least 2 * `n`.
 *
 *     If a null-pointer is passed, the memory is dynamically allocated using
 *     the `malloc` function in C and by calling the `new[]` operator in C++.
 *
 * @param generator
 *     Function to generate coordinates of a point.  The x-coordinate of the
 *     `i`-th point is generated by calling `generate(i, 0)`, and the
 *     y-coordinate of the point is generated by calling `generate(i, 1)`.
 *
 * @return
 *     Array of points of size 2 * `n` if `generator` is not a null-pointer;
 *     otherwise a null-pointer is returned.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  The
 *     points do not have to be true vertices---use `simplify_polygon` to
 *     exclude unnecessary points.  Even if the points are true vertices, they
 *     may not define a true polygon---use `check_polygon` to check for this.
 *     To be more sure of generating a true polygon, use `smart_random_polygon`.
 *
 *     The x-coordinates are generated by calling the `generator` function.  The
 *     coordinates are generated in the order: x_0, y_0, x_1, y_1, ...,
 *     x_n_minus_1, y_n_minus_1.
 *
 * @see malloc
 * @see simplify_polygon
 * @see check_polygon
 * @see smart_random_polygon
 *
 */
#if !defined(__cplusplus)
real_t* random_polygon (
    size_t n,
    real_t* P,
    real_t (* generator) (size_t, size_t)
)
#else
real_t* random_polygon (
    ::size_t n,
    real_t* P,
    real_t (* generator) (::size_t, ::size_t)
)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* INITIALISATION OF VARIABLES */

    /* Iteration index. */
    i = 0U;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If `n` == 0, break the `do while`-loop. */
        if (!n)
            break;

        /* If `generator` is a null-pointer, break the `do while` loop. */
        if (!generator)
            break;

        /* Allocate the memory for the array `P` if necessary. */
        if (!P)
#if !defined(__cplusplus)
            P = (real_t*)malloc(2U * n * sizeof *P);
#else
            P = new real_t[2U * n];
#endif /* __cplusplus */

        /* If the memory allocation has failed, break the `do while`-loop. */
        if (!P)
            break;

        /* Initialise the array of points to zeros. */
#if !defined(__cplusplus)
        memset(P, 0, 2U * n * sizeof *P);
#else
        ::memset(P, 0, 2U * n * sizeof *P);
#endif /* __cplusplus */

        /* Fill the array with random coordinates. */
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) = generator(i >> 1U, i & 1U);
    }
    while (false);

    /* Return the generated array of points. */
    return P;
}

/**
 * Generate points in a plane so that no two line segments intersect.
 *
 * Use this function to generate a polygon if it is not likely that the
 * generated array of points will be a polygon without additional checkings and
 * corrections (tries until satisfaction) using the `generator` function.
 * Otherwise use the `random_polygon` function.
 *
 * Caution: the function may fail if memory must be allocated for the resulting
 * array, but the allocation failed.  If that happens, the null-pointer is
 * returned.  Exceptions thrown by failed memory allocation in C++ are not
 * caught.
 *
 * @param n
 *     Number of points to generate.
 *
 * @param P
 *     Pointer to the coordinates of the first point in the array of size at
 *     least 2 * `n`.
 *
 *     If a null-pointer is passed, the memory is dynamically allocated using
 *     the `malloc` function in C and by calling the `new[]` operator in C++.
 *
 * @param generator
 *     Function to generate coordinates of a point.  The x-coordinate of the
 *     `i`-th point is generated by calling `generate(i, 0)`, and the
 *     y-coordinate of the point is generated by calling `generate(i, 1)`.
 *
 * @param out_iter_max
 *     Maximal number of outer iterations (attempts of generating a complete
 *     array satisfying the requirements).
 *
 * @param in_iter_max
 *     Maximal number of inner iterations (attempts of generating a single
 *     point satisfying the requirements).  At each new point the number of
 *     inner iterations starts at 0, but, if the maximal number of inner
 *     iterations has been exhausted on a single point, the algorithm
 *     immediately proceeds to the next outer iteration (if the maximal number
 *     of outer iterations has not been exhausted yet).
 *
 * @return
 *     Array of points of size 2 * `n` if `generator` is not a null-pointer;
 *     otherwise a null-pointer is returned.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Unlike
 *     the function `random_polygon`, it is guaranteed that no two disjoint
 *     pairs of consecutive points are end-points of intersecting linesegments,
 *     unless they share a common end-point in which case all the "edges"
 *     between them are actually the shared end-point.  The points do not have
 *     to be true vertices---use the function `simplify_polygon` to exclude
 *     unnecessary points.  Even if the points are true vertices, they may not
 *     define a true polygon---use the function `check_polygon` to check for
 *     this.  However, it is more likely that this function will generate a true
 *     polygon (simplifiable or not) than the function `random_polygon` if the
 *     `generator` function generates points uniformly distributed.
 *
 *     The x-coordinates are generated by calling the `generator` function.  The
 *     coordinates are generated in the order: x_0, y_0, x_1, y_1, ...,
 *     x_n_minus_1, y_n_minus_1.  Coordinates of the same point are being
 *     generated until it satisfies the requirements.  In each outer iteration
 *     all points are generated (no value is passed to the next iteration).
 *
 *     If the requirements could not have been satisfied after exhausting the
 *     maximal numbers of iterations, all the points are set to coordinates
 *     (`lambda`, `lambda`).  However, if a null-pointer was passed as the
 *     argument `P`, a null-pointer will be returned as well.
 *
 *
 * @see malloc
 * @see simplify_polygon
 * @see check_polygon
 * @see random_polygon
 *
 */
#if !defined(__cplusplus)
real_t* smart_random_polygon (
    size_t n,
    real_t* P,
    real_t (* generator) (size_t, size_t),
    size_t out_iter_max,
    size_t in_iter_max
)
#else
real_t* smart_random_polygon (
    ::size_t n,
    real_t* P,
    real_t (* generator) (::size_t, ::size_t),
    ::size_t out_iter_max,
    ::size_t in_iter_max
)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Flags for checking if the given pointer is a null-pointer and for
     * checking the requirements. */
    bool P_null;
    bool bad;

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t r;
    size_t i;
    size_t j;
#else
    ::size_t r;
    ::size_t i;
    ::size_t j;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_i0;
    real_t* y_i0;
    real_t* x_i1;
    real_t* y_i1;
    real_t* x_j0;
    real_t* y_j0;
    real_t* x_j1;
    real_t* y_j1;

    /* Differences in coordinates. */
    real_t dx_i;
    real_t dy_i;
    real_t dx_j;
    real_t dy_j;

    /* Signs of expressions of lines evaluated at certain points. */
    sign_t s_i0;
    sign_t s_i1;
    sign_t s_j0;
    sign_t s_j1;

    /* INITIALISATION OF VARIABLES */

    /* Flags for checking if the given pointer is a null-pointer and for
     * checking the requirements. */
    P_null = false;
    bad = false;

    /* Iteration indices. */
    r = 0U;
    i = 0U;
    j = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_i0 = (real_t*)(NULL);
    y_i0 = (real_t*)(NULL);
    x_i1 = (real_t*)(NULL);
    y_i1 = (real_t*)(NULL);
    x_j0 = (real_t*)(NULL);
    y_j0 = (real_t*)(NULL);
    x_j1 = (real_t*)(NULL);
    y_j1 = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_i0 = reinterpret_cast<real_t*>(NULL);
    y_i0 = reinterpret_cast<real_t*>(NULL);
    x_i1 = reinterpret_cast<real_t*>(NULL);
    y_i1 = reinterpret_cast<real_t*>(NULL);
    x_j0 = reinterpret_cast<real_t*>(NULL);
    y_j0 = reinterpret_cast<real_t*>(NULL);
    x_j1 = reinterpret_cast<real_t*>(NULL);
    y_j1 = reinterpret_cast<real_t*>(NULL);
#else
    x_i0 = nullptr;
    y_i0 = nullptr;
    x_i1 = nullptr;
    y_i1 = nullptr;
    x_j0 = nullptr;
    y_j0 = nullptr;
    x_j1 = nullptr;
    y_j1 = nullptr;
#endif /* __cplusplus */

    /* Differences in coordinates. */
    dx_i = 0.0;
    dy_i = 0.0;
    dx_j = 0.0;
    dy_j = 0.0;

    /* Signs of expressions of lines evaluated at certain points. */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
    s_i0 = zero;
    s_i1 = zero;
    s_j0 = zero;
    s_j1 = zero;
#else
    s_i0 = sign_t::zero;
    s_j1 = sign_t::zero;
    s_i0 = sign_t::zero;
    s_j1 = sign_t::zero;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* If the given pointer `P` is a null-pointer, set the flag for checking it
     * to `true`. */
    if (!P)
        P_null = true;

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If `n` == 0, break the `do while`-loop. */
        if (!n)
            break;

        /* Allocate the memory for the array `P` if necessary. */
        if (P_null)
#if !defined(__cplusplus)
            P = (real_t*)malloc(2U * n * sizeof *P);
#else
            P = new real_t[2U * n];
#endif /* __cplusplus */

        /* If the memory allocation has failed, break the `do while`-loop. */
        if (!P)
            break;

        /* Initialise the array of points to zeros. */
#if !defined(__cplusplus)
        memset(P, 0, 2U * n * sizeof *P);
#else
        ::memset(P, 0, 2U * n * sizeof *P);
#endif /* __cplusplus */

        /* If the maximal number of outer and inner iterations is 0, set all
         * values in the array to `lambda` and break the `do while`-loop. */
        if (!(out_iter_max && in_iter_max))
        {
            /* If the given pointer `P` was a null-pointer, deallocate the
             * memory allocated for the array. */
            if (P_null)
            {
#if !defined(__cplusplus)
                free(P);
                P = (real_t*)(NULL);
#else
                delete[] P;
#if (__cplusplus) < 201103L
                P = reinterpret_cast<real_t*>(NULL);
#else
                P = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */
            }
            /* Otherwise set all the values in the array to `lambda`. */
            else
                for (i = 0U; (i >> 1U) < n; ++i)
                    *(P + i) = lambda;

            /* Break the `do while`-loop. */
            break;
        }

        /* Generate random points until the requirements are satisfied or unitl
         * the maximal number of outer iterations is exhausted. */
        do
        {
            /* Initialise the array of points to zeros. */
#if !defined(__cplusplus)
            memset(P, 0, 2U * n * sizeof *P);
#else
            ::memset(P, 0, 2U * n * sizeof *P);
#endif /* __cplusplus */

            /* Extract the coordinates of the first point---point P_i0. */
            x_i0 = P;
            y_i0 = x_i0 + 1U;

            /* Generate random coordinates for the point P_i0. */
            *x_i0 = generator(0U, 0U);
            *y_i0 = generator(0U, 1U);

            /* If `n` == 1, break the `do while`-loop. */
            if (n == 1U)
                break;

            /* Extract the coordinates of the second point---point P_i1. */
            x_i1 = P + 2U;
            y_i1 = x_i1 + 1U;

            /* Generate random coordinates for the point P_i1. */
            *x_i1 = generator(1U, 0U);
            *y_i1 = generator(1U, 1U);

            /* Iterate over the rest of the points. */
            for (i = 2U; i < n; ++i)
            {
                /* Set the point P_i0 to point P_i1. */
                x_i0 = x_i1;
                y_i0 = y_i1;

                /* Extract the coordinates of the `i`-th point---point P_i1. */
                x_i1 = P + 2U * i;
                y_i1 = x_i1 + 1U;

                /* Set the flag `bad` to `true` (assume the requirements are not
                 * satisfied). */
                bad = true;

                /* Generate random coordinates for the point P_i1 until the
                 * requirements are satisfied or until the maximal number of
                 * inner iterations is exhausted. */
                for (r = 0U; bad && r < in_iter_max; ++r)
                {
                    /* Set the flag `bad` to `false` (assume the requirements
                     * are satisfied). */
                    bad = false;

                    /* Generate random coordinates for the point P_i1. */
                    *x_i1 = generator(i, 0U);
                    *y_i1 = generator(i, 1U);

                    /* Compute the differences in coordinates of points P_i0 and
                     * P_i1. */
                    dx_i = *x_i1 - *x_i0;
                    dy_i = *y_i1 - *y_i0;

                    /* Iterate over all the previous points and check if any
                     * edge intersects with the line segment P_i0 P_i1. */
                    for (j = 0U; j + 1U < i; ++j)
                    {
                        /* Extract the coordinates of the `j`-th point---point
                         * P_j0. */
                        x_j0 = P + 2U * j;
                        y_j0 = x_j0 + 1U;

                        /* Extract the coordinates of the ((`j` + 1) mod n)-th
                         * point---point P_j1. */
                        x_j1 = P + 2U * incmod(j, n);
                        y_j1 = x_j1 + 1U;

                        /* If the point P_j0 is in fact point P_i1 or the point
                         * P_j1 is in fact point Pi0, break the `for`-loop. */
                        if (
                            (x_j0 == x_i1 && y_j0 == y_i1) ||
                            (x_j1 == x_i0 && y_j1 == y_i0)
                        )
                            break;

                        /* Compute the differences in coordinates of points P_j0
                         * and P_j1. */
                        dx_j = *x_j1 - *x_j0;
                        dy_j = *y_j1 - *y_j0;

                        /* Compute the signs of expressions of the line
                         * P_j0 P_j1 evaluated at points P_i0 and P_i1, and of
                         * the line P_i0 P_i1 evaluated at points P_j0 and
                         * P_j1. */
                        s_i0 = rsign(
                            dx_j * (*y_i0 - *y_j0) - dy_j * (*x_i0 - *x_j0)
                        );
                        s_i1 = rsign(
                            dx_j * (*y_i1 - *y_j0) - dy_j * (*x_i1 - *x_j0)
                        );
                        s_j0 = rsign(
                            dx_i * (*y_j0 - *y_i0) - dy_i * (*x_j0 - *x_i0)
                        );
                        s_j1 = rsign(
                            dx_i * (*y_j1 - *y_i0) - dy_i * (*x_j1 - *x_i0)
                        );

                        /* If all four points are on the same line, continue to
                         * the next iteration (next points P_j0 and P_j1). */
#if !defined(__cplusplus)
                        if (!((int)s_i0 && (int)s_i1 && (int)s_j0 && (int)s_j1))
#else
                        if (
                            !(
                                static_cast<int>(s_i0) &&
                                static_cast<int>(s_i1) &&
                                static_cast<int>(s_j0) &&
                                static_cast<int>(s_j1)
                            )
                        )
#endif /* __cplusplus */
                            continue;

                        /* If the points P_i0 and P_i1 are on the opposite sides
                         * of the line P_j0 P_j1 (allowing them to be on the
                         * line as well), and the points P_j0 and P_j1 are on
                         * the opposite sides of the line P_i0 P_i1 (again,
                         * allowing the points to be on the line), the line
                         * segments P_i0 P_i1 and P_j0 P_j1 are crossing.  If
                         * that is the case, set the flag `bad` to `true` and
                         * break the `for`-loop. */
#if !defined(__cplusplus)
                        if (
                            !(
                                (int)s_i0 * (int)s_i1 == 1 ||
                                (int)s_j0 * (int)s_j1 == 1
                            )
                        )
#else
                        if (
                            !(
                                static_cast<int>(s_i0) *
                                    static_cast<int>(s_i1) ==
                                    1 ||
                                static_cast<int>(s_j0) *
                                    static_cast<int>(s_j1) ==
                                    1
                            )
                        )
#endif /* __cplusplus */
                        {
                            /* Set the flag `bad` to `true`. */
                            bad = true;

                            /* Break the `for`-loop. */
                            break;
                        }
                    }
                }

                /* If a "good" point could not be generated in `in_iter_max`
                 * iterations, break the `for`-loop. */
                if (bad)
                    break;
            }

            /* If all the points have been succesfully generated, break the
             * `do while`-loop. */
            if (!bad)
                break;

            /* Set all the values in the array to `lambda` (annul all the
             * points). */
            for (j = 0U; (j >> 1U) < n; ++j)
                *(P + j) = lambda;
        }
        while (--out_iter_max);

        /* If all the outer itterations have been exhausted and the original
         * pointer `P` was a null-pointer, free the memory for the array. */
        if (!out_iter_max && P_null)
        {
            /* Clear the memory in the array. */
#if !defined(__cplusplus)
            memset(P, 0, 2U * n * sizeof *P);
#else
            ::memset(P, 0, 2U * n * sizeof *P);
#endif /* __cplusplus */

            /* Deallocate the memory. */
#if !defined(__cplusplus)
            free(P);
            P = (real_t*)(NULL);
#else
            delete[] P;
#if (__cplusplus) < 201103L
            P = reinterpret_cast<real_t*>(NULL);
#else
            P = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */
        }
    }
    while (false);

    /* Return the generated array of points. */
    return P;
}

/**
 * Simplify an array of points into an array that could be easily checked if it
 * represents an ordered set of true vertices of a polygon.
 *
 * If a point in the given array of points is on the line segment between its
 * neighbours, it is deleted.  Note that the first and the last points are
 * neigbouring (the array is cyclical).
 *
 * The function mutates the given array.  All the points that are kept will be
 * at the beginning of the array, and all the deleted points will be set to
 * coordinates (`lambda`, `lambda`).  The first point in the array after calling
 * the function may be different than the first point in the array before
 * calling the function, but the cyclical order of the points is preserved.  No
 * new points are added in the array, some points are only deleted.
 *
 * Caution: the function may fail if memory cannot be allocated for some
 * auxiliary additional arrays.  If that happens, the polygon may not be
 * fully simplified.  Exceptions thrown by failed memory allocation in C++ are
 * not caught.
 *
 * @param n
 *     Maximal number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 * @return
 *     Pointer to the end of the array of points `P` after deleting the
 *     unnecessary points.  All the values in the given array after the position
 *     that is returned until the position 2 * `n` are filled with the value
 *     `lambda`.
 *
 */
#if !defined(__cplusplus)
real_t* simplify_polygon (size_t n, real_t* P)
#else
real_t* simplify_polygon (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Auxiliary number of points. */
#if !defined(__cplusplus)
    size_t m;
#else
    ::size_t m;
#endif /* __cplusplus */

    /* Auxiliary array of points. */
    real_t* Q;

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
    size_t k;
#else
    ::size_t i;
    ::size_t j;
    ::size_t k;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_0;
    real_t* y_0;
    real_t* x_1;
    real_t* y_1;
    real_t* x_2;
    real_t* y_2;

    /* Differences in coordinates. */
    real_t dx_0_1;
    real_t dy_0_1;
    real_t dx_0_2;
    real_t dy_0_2;

    /* Signs of differences in coordinates. */
    sign_t sdx_1;
    sign_t sdy_1;
    sign_t sdx_2;
    sign_t sdy_2;

    /* INITIALISATION OF VARIABLES */

    /* Auxiliary number of points. */
    m = n;

    /* Auxiliary array of points. */
#if !defined(__cplusplus)
    Q = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    Q = reinterpret_cast<real_t*>(NULL);
#else
    Q = nullptr;
#endif /* __cplusplus */

    /* Iteration indices. */
    i = 0U;
    j = 0U;
    k = 0U;

    /* Auxiliary pointers to coordinates of points. */
    x_0 = P;
    y_0 = x_0 + 1U;
    x_1 = P;
    y_1 = x_1 + 1U;
    x_2 = P;
    y_2 = x_2 + 1U;

    /* Differences in coordinates. */
    dx_0_1 = 0.0;
    dy_0_1 = 0.0;
    dx_0_2 = 0.0;
    dy_0_2 = 0.0;

    /* Signs of differences in coordinates. */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
    sdx_1 = zero;
    sdy_1 = zero;
    sdx_2 = zero;
    sdy_2 = zero;
#else
    sdx_1 = sign_t::zero;
    sdy_1 = sign_t::zero;
    sdx_2 = sign_t::zero;
    sdy_2 = sign_t::zero;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* If the pointer `P` is a null-pointer, set the number `n` to 0. */
    if (!P)
        n = 0U;

    /* Iterate over the points. */
    for (i = 0U; i < n; ++i)
    {
        /* Extract the coordinates of the `i`-th point---point P_0. */
        x_0 = P + 2U * i;
        y_0 = x_0 + 1U;

        /* Initialise the number `m` to the value of `n`. */
        m = n;

        /* Find the first point different from the `i`-th point---point P_1.
         * For all the skipped points, decrement the number `m`. */
        for (j = incmod(i, n); j != i; j = incmod(j, n))
        {
            /* Extract the coordinates of the `j`-th point. */
            x_1 = P + 2U * j;
            y_1 = x_1 + 1U;

            /* If the `j`-th point is different from the point P_0, break the
             * `for`-loop. */
            if (*x_1 != *x_0 || *y_1 != *y_0)
                break;

            /* Decrement the number `m`. */
            --m;
        }

        /* If no different point P_1 is found, set the coordinates of the 0th
         * point to the coordinates of the point P_0, annul all the other points
         * and set the number `n` to 1. When done, break the `for`-loop. */
        if (j == i)
        {
            /* Set the coordinates of the 0-th point to the coordinates of the
             * point P_0. */
            *(P + 0U) = *x_0;
            *(P + 1U) = *y_0;

            /* Annul all points except the 0th point. */
            for (k = 2U; (k >> 1U) < n; ++k)
                *(P + k) = lambda;

            /* Set the number `n` to 1. */
            n = 1U;

            /* Break the `for`-loop. */
            break;
        }

        /* Compute the differences in coordinates of points P_0 and P_1. */
        dx_0_1 = *x_1 - *x_0;
        dy_0_1 = *y_1 - *y_0;

        /* Compute the signs of the differences in coordinates of points P_0 and
         * P_1. */
        sdx_1 = rsign(dx_0_1);
        sdy_1 = rsign(dy_0_1);

        /* Find the first point that is not on the directed line P_0 P_1 after
         * the point P_1---point P_2.  For all the skipped points, decrement the
         * number `m`. */
        for (k = incmod(j, n); k != i; k = incmod(k, n))
        {
            /* Extract the coordinates of the `j`-th point. */
            x_2 = P + 2U * k;
            y_2 = x_2 + 1U;

            /* Compute the differences in coordinates of points P_0 and the
             * `k`-th point. */
            dx_0_2 = *x_2 - *x_0;
            dy_0_2 = *y_2 - *y_0;

            /* Compute the signs of the differences in coordinates of points P_1
             * and the `k`-th point. */
            sdx_2 = rsign(*x_2 - *x_1);
            sdy_2 = rsign(*y_2 - *y_1);

            /* If the `k`-th point is not on the line P_0 P_1 or if the signs of
             * the differences in coordinates of points P_1 and the `k`-th point
             * differ from the signs until the `k`-th point, the `k`-th point is
             * not on the directed line P_0 P_1 after the point P_1.  If that is
             * the case, break the `for`-loop. */
            if (
                !(
                    dx_0_1 * dy_0_2 == dy_0_1 * dx_0_2 &&
                    (sdx_2 == sdx_1 && sdy_2 == sdy_1)
                )
            )
                break;

            /* Set the coordinates of the point P_1 to (`x_2`, `y_2`). */
            x_1 = x_2;
            y_1 = y_2;

            /* Update the differences in coordinates of points P_0 and P_1. */
            dx_0_1 = dx_0_2;
            dy_0_1 = dy_0_2;

            /* Update the signs of the differences in the coordinates of the
             * preceeding two points. */
            sdx_1 = sdx_2;
            sdy_1 = sdy_2;

            /* Decrement the number `m`. */
            --m;
        }

        /* If no point was skipped, continue to the next iteration. */
        if (m == n)
            continue;

        /* Allocate memory for an auxiliary array of points. */
#if !defined(__cplusplus)
        Q = (real_t*)malloc(2U * m * sizeof *Q);
#else
        Q = new real_t[2U * m];
#endif /* __cplusplus */

        /* If the memory allocation has failed, break the `for`-loop. */
        if (!Q)
            break;

        /* Initialise the auxiliary array of points to zeros. */
#if !defined(__cplusplus)
        memset(Q, 0, 2U * m * sizeof *Q);
#else
        ::memset(Q, 0, 2U * m * sizeof *Q);
#endif /* __cplusplus */

        /* Set the coordinates of the 0th point in the auxiliary array to
         * coordinates of the point P_0. */
        *(Q + 0U) = *x_0;
        *(Q + 1U) = *y_0;

        /* Decrement the index `k` in modular arithmetics modulo `n` so that it
         * points to the point P_1. */
        k = decmod(k, n);

        /* Copy the points from the point P_1 onward to the auxiliary array. */
        if (n + 1U - k < m)
        {
#if !defined(__cplusplus)
            memcpy(Q + 2U, P + 2U * k, 2U * (n - k) * sizeof *P);
            memcpy(
                Q + 2U * (n - k) + 2U,
                P,
                (2U * (m + k - n) - 2U) * sizeof *P
            );
#else
            ::memcpy(Q + 2U, P + 2U * k, 2U * (n - k) * sizeof *P);
            ::memcpy(
                Q + 2U * (n - k) + 2U,
                P,
                (2U * (m + k - n) - 2U) * sizeof *P
            );
#endif /* __cplusplus */
        }
        else
#if !defined(__cplusplus)
            memcpy(Q + 2U, P + 2U * k, (2U * m - 2U) * sizeof *P);
#else
            ::memcpy(Q + 2U, P + 2U * k, (2U * m - 2U) * sizeof *P);
#endif /* __cplusplus */

        /* Copy the content from the auxiliary array to the beginning of the
         * original array. */
#if !defined(__cplusplus)
        memcpy(P, Q, 2U * m * sizeof *Q);
#else
        ::memcpy(P, Q, 2U * m * sizeof *Q);
#endif /* __cplusplus */

        /* Annul all the points from the index `m` until the end in the original
         * array. */
        for (j = 2U * m; (j >> 1U) < n; ++j)
            *(P + j) = lambda;

        /* Clear the memory in the auxiliary array. */
#if !defined(__cplusplus)
        memset(Q, 0, 2U * m * sizeof *Q);
#else
        ::memset(Q, 0, 2U * m * sizeof *Q);
#endif /* __cplusplus */

        /* Deallocate the memory allocated for the auxiliary array. */
#if !defined(__cplusplus)
        free(Q);
        Q = (real_t*)(NULL);
#else
        delete[] Q;
#if (__cplusplus) < 201103L
        Q = reinterpret_cast<real_t*>(NULL);
#else
        Q = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

        /* Update the number `n`---set it to the value of `m`. */
        n = m;

        /* Set the value of the index `i` to 0 (the point P_0 is now at the
         * beginning of the array `P`). */
        i = 0U;
    }

    /* Return the pointer to the first deleted point (if any). */
    return P + 2U * n;
}

/**
 * Reorder an array of points into the conventional order.
 *
 * The conventional order of points is the following:
 *     1.  the first point is the point with the smallest second coordinate; if
 *         there are more than one points with the smallest second coordinate,
 *         the point with the largest first coordinate among them is the first
 *         point,
 *     2.  the points are listed counterclockwise.
 * No new points are added nor any of the points is deleted.  Note that the
 * first and the last points are neigbouring (the array is cyclical).
 *
 * After choosing the point to be the first, the clockwise order of the points
 * is checked by calculating the sign of the cross product of the last and the
 * first edge (the edge connecting the last point and the first point, and the
 * edge connecting the first point and the second point).  The order is
 * considered clockwise if the sign of the product is -1 (`minus`), otherwise
 * (even if the sign is 0 (`zero`)) the order is considered counterclockwise.
 *
 * The vertices of a polygon will be ordered conventionally if the
 * polygon has been simplified beforehand via the `simplify_polygon` function
 * and if the simplified polygon "has passed" the `check_polygon` function's
 * test.  However, even without the simplification the vertices may actually be
 * ordered conventionally.
 *
 * If any of the coordinates is NaN, the result may be unexpected.
 *
 * The given array is not mutated in the function.
 *
 * Caution: the function may fail if memory cannot be allocated for some
 * auxiliary additional arrays or if the memory allocation for the `flip`
 * function fails.  If any of that happens, the array may not be correctly
 * reordered.  Exceptions thrown by failed memory allocation in C++ are not
 * caught.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 * @see simplify_polygon
 * @see check_polygon
 * @see simplify_check_polygon
 *
 */
#if !defined(__cplusplus)
void correct_polygon_orientation (size_t n, real_t* P)
#else
void correct_polygon_orientation (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Auxiliary array of points. */
    real_t* Q;

    /* Index of the first point. */
#if !defined(__cplusplus)
    size_t v;
#else
    ::size_t v;
#endif /* __cplusplus */

    /* Iteration indices. */
    size_t i;
    size_t j;

    /* Pointers to coordinates of the first point. */
    real_t* x_v;
    real_t* y_v;

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_i;
    real_t* y_i;
    real_t* x_j;
    real_t* y_j;

    /* INITIALISATION OF VARIABLES */

    /* Auxiliary array of points. */
#if !defined(__cplusplus)
    Q = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    Q = reinterpret_cast<real_t*>(NULL);
#else
    Q = nullptr;
#endif /* __cplusplus */

    /* Index of the first point. */
    v = 0U;

    /* Iteration indices. */
    i = 0U;
    j = 0U;

    /* Pointers to coordinates of the first point. */
    x_v = P;
    y_v = x_v + 1U;

    /* Auxiliary pointers to coordinates of points. */
    x_i = P;
    y_i = x_i + 1U;
    x_j = P;
    y_j = x_j + 1U;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If the pointer `P` is a null-pointer, set the number `n` to 0 and
         * break the `do while`-loop. */
        if (!P)
        {
            /* Set the numbre `n` to 0. */
            n = 0U;

            /* Break the `do while`-loop. */
            break;
        }

        /* If the number of points is less than 2, break the `do while`-loop. */
        if (n < 2U)
            break;

        /* Iterate over the rest of the points to find the true first point
         * (when the array is correctly ordered). */
        for (i = 1U; i < n; ++i)
        {
            /* Extract the coordinates of the `i`-th point---point P_i. */
            x_i = P + 2U * i;
            y_i = x_i + 1U;

            /* If the second coordinate of the point P_i is strictly smaller
             * than the second coordinate of the point P_v or if their second
             * coordinates are the same but the first coordinate of the point
             * P_i is strictly larger than the first coordinate of the point
             * P_v, update the index `v` to the value of `i` and the coordinates
             * of the point P_v to the coordinates of the point P_i. */
            if (*y_i < *y_v || (*y_i == *y_v && *x_v < *x_i))
            {
                /* Set the index `v` to the value of `i`. */
                v = i;

                /* Set the coordinates of the point P_v to the coordinates of
                 * the point P_i. */
                x_v = x_i;
                y_v = y_i;
            }
        }

        /* Compute the indices of the last and the second position in the
         * array. */
        i = n - 1U;
        j = 1U;

        /* Extract the (pointers to the) last and the second point in the
         * array. */
        x_i = P + 2U * i;
        y_i = x_i + 1U;
        x_j = P + 2U * j;
        y_j = x_j + 1U;

        /* If the index `v` is not 0 (if another point must be on the beginning
         * of the array), rotate the array. */
        if (v)
        {
            /* Allocate memory for the auxiliary array of points. */
#if !defined(__cplusplus)
            Q = (real_t*)malloc(2U * n * sizeof *Q);
#else
            Q = new real_t[2U * n];
#endif /* __cplusplus */

            /* If the memory allocation has failed, break the
             * `do while`-loop. */
            if (!Q)
                break;

            /* Initialise the auxiliary array of points to zeros. */
#if !defined(__cplusplus)
            memset(Q, 0, 2U * n * sizeof *Q);
#else
            ::memset(Q, 0, 2U * n * sizeof *Q);
#endif /* __cplusplus */

            /* Copy the content from the original array to the auxiliary
             * array. */
#if !defined(__cplusplus)
            memcpy(Q, P + 2U * v, 2U * (n - v) * sizeof *P);
            memcpy(Q + 2U * (n - v), P, 2U * v * sizeof *P);
#else
            ::memcpy(Q, P + 2U * v, 2U * (n - v) * sizeof *P);
            ::memcpy(Q + 2U * (n - v), P, 2U * v * sizeof *P);
#endif /* __cplusplus */

            /* Copy the content from the auxiliary array to the original
             * array. */
#if !defined(__cplusplus)
            memcpy(P, Q, 2U * n * sizeof *Q);
#else
            ::memcpy(P, Q, 2U * n * sizeof *Q);
#endif /* __cplusplus */

            /* Clear the memory in the auxiliary array. */
#if !defined(__cplusplus)
            memset(Q, 0, 2U * n * sizeof *Q);
#else
            ::memset(Q, 0, 2U * n * sizeof *Q);
#endif /* __cplusplus */

            /* Deallocate the memory allocated for the auxiliary array. */
#if !defined(__cplusplus)
            free(Q);
            Q = (real_t*)(NULL);
#else
            delete[] Q;
#if (__cplusplus) < 201103L
            Q = reinterpret_cast<real_t*>(NULL);
#else
            Q = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

            /* Set the value of the index `v` to 0 (the point P_v is now
             * indeed at the beginning of the array `P`). */
            v = 0U;

            /* Set the coordinates of the point P_v to coordinates of the first
             * point in the array `P`. */
            x_v = P;
            y_v = x_v + 1U;
        }

        /* If the sign of the cross product of the last and the first edge is
         * -1 (`minus`), flip the rest of the array (excluding the first
         * element). */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
        if (
            rsign(
                (*x_v - *x_i) * (*y_j - *y_i) - (*x_j - *x_i) * (*y_v - *y_i)
            ) == minus
        )
#else
        if (
            rsign(
                (*x_v - *x_i) * (*y_j - *y_i) - (*x_j - *x_i) * (*y_v - *y_i)
            ) == sign_t::minus
        )
#endif /* __cplusplus */
            flip(P + 2U, n - 1U, 2U * sizeof *P);
    }
    while (false);
}

/**
 * Translate an array of points so that all the coordinates stretch inside a
 * Certesian product of two symmetric closed intervals.
 *
 * All the x-coordinates of the points are decremented by
 * (`x_min` + `x_max`) / 2, and all the y-coordinates are decremented by
 * (`y_min` + `y_max`) / 2, where `x_min`, `x_max`, `y_min` and `y_max` are the
 * smallest and the largest x-coordinates and the smallest and the largest
 * y-coordinates respectively.
 *
 * The function mutates the given array.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 */
#if !defined(__cplusplus)
void centralise_polygon (size_t n, real_t* P)
#else
void centralise_polygon (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Extreme and middle coordinates of points. */
    real_t x_min;
    real_t y_min;
    real_t x_mid;
    real_t y_mid;
    real_t x_max;
    real_t y_max;

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_i;
    real_t* y_i;

    /* INITIALISATION OF VARIABLES */

    /* Extreme and middle coordinates of points. */
    x_min = 0.0;
    y_min = 0.0;
    x_mid = 0.0;
    y_mid = 0.0;
    x_max = 0.0;
    y_max = 0.0;

    /* Iteration index. */
    i = 0U;

    /* Auxiliary pointers to coordinates of points. */
    x_i = P;
    y_i = x_i + 1U;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If the pointer `P` is a null-pointer, set the number `n` to 0 and
         * break the `do while`-loop. */
        if (!P)
        {
            /* Set the numbre `n` to 0. */
            n = 0U;

            /* Break the `do while`-loop. */
            break;
        }

        /* If the number of points is 0, break the `do while`-loop. */
        if (!n)
            break;

        /* Initialise the extreme coordinates to the coordinates of the first
         * point. */
        x_min = *P;
        y_min = *(P + 1U);
        x_max = *P;
        y_max = *(P + 1U);

        /* Iterate over the rest of the points to find the most extreme
         * coordinates. */
        for (i = 1U; i < n; ++i)
        {
            /* Extract the coordinates of the `i`-th point. */
            x_i = P + 2U * i;
            y_i = x_i + 1U;

            /* If either of the current point's coordinates is more extreme than
             * the most extreme coordinates so far, update the extreme
             * coordinates accordingly. */
            if (*x_i < x_min)
                x_min = *x_i;
            if (x_max < *x_i)
                x_max = *x_i;
            if (*y_i < y_min)
                y_min = *y_i;
            if (y_max < *y_i)
                y_max = *y_i;
        }

        /* Compute the middle coordinates. */
        x_mid = x_min + 0.5 * (x_max - x_min);
        y_mid = y_min + 0.5 * (y_max - y_min);

        /* Iterate over the points and translate their coordinates. */
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) -= (i & 1U) ? y_mid : x_mid;
    }
    while (false);
}

/**
 * Check if an array of points is an ordered set of true vertices of a polygon.
 *
 * If any three consecutive points are on the same line (or are the same point),
 * the array does not represent true vertices of a polygon in the order given.
 * Also, if any two pairs of neigbouring points such that the pairs do not have
 * a mutual point represent ending points of intersecting line segments (we
 * observe line segments between two points in a single pair, not between points
 * from different pairs), the points in the array are not ordered vertices of a
 * polygon.  Note that the first and the last points are neigbouring (the array
 * is cyclical).
 *
 * If the number of true vertices is indeed greater than 3 and no two edges
 * intersect except the neigbouring edges in their mutual end-points, the
 * returned value may be `false` if a point is given that is not a true vertex
 * (if it is on the line segment between its neigbouring points).  If the
 * number of true vertices is allowed to be less than `n`, it is then better to
 * simplify the array `P` before checking for the polygon (using the
 * `simplify_polygon` function).  Function `simplify_check_polygon` may be
 * useful for this purpose.
 *
 * The given array is not mutated in the function.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 * @return
 *     Value `true` if `P` is not a null-pointer, the number of points is at
 *     least 3, no three consecutive points are on the same line and no two
 *     line segments that do not share a same end-point intersect; otherwise
 *     value `false`.
 *
 * @see simplify_polygon
 * @see simplify_check_polygon
 *
 */
#if !defined(__cplusplus)
bool check_polygon (size_t n, const real_t* P)
#else
bool check_polygon (::size_t n, const real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Answer. */
    bool answer;

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
#else
    ::size_t i;
    ::size_t j;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    const real_t* x_i0;
    const real_t* y_i0;
    const real_t* x_i1;
    const real_t* y_i1;
    const real_t* x_j0;
    const real_t* y_j0;
    const real_t* x_j1;
    const real_t* y_j1;

    /* Differences in coordinates. */
    real_t dx_i;
    real_t dy_i;
    real_t dx_j;
    real_t dy_j;

    /* Signs of expressions of lines evaluated at certain points. */
    sign_t s_i0;
    sign_t s_i1;
    sign_t s_j0;
    sign_t s_j1;

    /* INITIALISATION OF VARIABLES */

    /* Answer. */
    answer = false;

    /* Iteration indices. */
    i = 0U;
    j = 0U;

    /* Auxiliary pointers to coordinates of points. */
    x_i0 = P;
    y_i0 = x_i0 + 1U;
    x_i1 = P;
    y_i1 = x_i1 + 1U;
    x_j0 = P;
    y_j0 = x_j0 + 1U;
    x_j1 = P;
    y_j1 = x_j1 + 1U;

    /* Differences in coordinates. */
    dx_i = 0.0;
    dy_i = 0.0;
    dx_j = 0.0;
    dy_j = 0.0;

    /* Signs of expressions of lines evaluated at certain points. */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
    s_i0 = zero;
    s_i1 = zero;
    s_j0 = zero;
    s_j1 = zero;
#else
    s_i0 = sign_t::zero;
    s_i1 = sign_t::zero;
    s_j0 = sign_t::zero;
    s_j1 = sign_t::zero;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* Initialise the answer to `true` (assume the points define a true
     * polygon). */
    answer = true;

    /* If the pointer `P` is a null-pointer, set the number `n` to 0 and set the
     * answer to `false`. */
    if (!P)
    {
        /* Set the number `n` to 0. */
        n = 0U;

        /* Set the answer to `false`. */
        answer = false;
    }

    /* If the number of points is strictly less than 3, set the answer to
     * `false`. */
    if (n < 3U)
        answer = false;

    /* Iterate over the points.  If the answer becomes `false`, immediately
     * break the `for`-loop. */
    for (i = 0U; answer && i < n; ++i)
    {
        /* Extract the coordinates of the `i`-th point---point P_i0. */
        x_i0 = P + 2U * i;
        y_i0 = x_i0 + 1U;

        /* Extract the coordinates of the ((`i` + 1) mod n)-th point---point
         * P_i1. */
        x_i1 = P + 2U * incmod(i, n);
        y_i1 = x_i1 + 1U;

        /* If the points P_i0 and P_i1 are coordinately the same, set the answer
         * to `false` and break the `for`-loop. */
        if (*x_i1 == *x_i0 && *y_i1 == *y_i0)
        {
            /* Set the answer to `false`. */
            answer = false;

            /* Break the `for`-loop. */
            break;
        }

        /* Compute the index `j` of the point directly preceeding the point
         * P_i0. */
        j = decmod(i, n);

        /* Extract the coordinates of the `j`-th point. */
        x_j1 = P + 2U * j;
        y_j1 = x_j1 + 1U;

        /* If the point P_i0 is on the line through the `j`-th point and the
         * point P_i1, set the answer to `false` and break the `for`-loop. */
        if (
            (*x_i1 - *x_j1) * (*y_i0 - *y_j1) ==
                (*y_i1 - *y_j1) * (*x_i0 - *x_j1)
        )
        {
            /* Set the answer to `false`. */
            answer = false;

            /* Break the `for`-loop. */
            break;
        }

        /* Compute the differences in coordinates of points P_i0 and P_i1. */
        dx_i = *x_i1 - *x_i0;
        dy_i = *y_i1 - *y_i0;

        /* Iterate over the points after the point P_i1 and check if the edge
         * P_i0 P_i1 intersect with any successive edge. */
        for (j = i + 2U; j < n; ++j)
        {
            /* Extract the coordinates of the `j`-th point---point P_j0. */
            x_j0 = P + 2U * j;
            y_j0 = x_j0 + 1U;

            /* Extract the coordinates of the ((`j` + 1) mod n)-th point---
             * point P_j1. */
            x_j1 = P + 2U * incmod(j, n);
            y_j1 = x_j1 + 1U;

            /* If the point P_j0 is in fact point P_i1 or the point P_j1 is in
             * fact point Pi0, break the `for`-loop. */
            if (
                (x_j0 == x_i1 && y_j0 == y_i1) || (x_j1 == x_i0 && y_j1 == y_i0)
            )
                break;

            /* Compute the differences in coordinates of points P_j0 and
             * P_j1. */
            dx_j = *x_j1 - *x_j0;
            dy_j = *y_j1 - *y_j0;

            /* Compute the signs of expressions of the line P_j0 P_j1 evaluated
             * at points P_i0 and P_i1, and of the line P_i0 P_i1 evaluated at
             * points P_j0 and P_j1. */
            s_i0 = rsign(dx_j * (*y_i0 - *y_j0) - dy_j * (*x_i0 - *x_j0));
            s_i1 = rsign(dx_j * (*y_i1 - *y_j0) - dy_j * (*x_i1 - *x_j0));
            s_j0 = rsign(dx_i * (*y_j0 - *y_i0) - dy_i * (*x_j0 - *x_i0));
            s_j1 = rsign(dx_i * (*y_j1 - *y_i0) - dy_i * (*x_j1 - *x_i0));

            /* If all four points are on the same line, continue to the next
             * iteration (next points P_j0 and P_j1). */
#if !defined(__cplusplus)
            if (!((int)s_i0 && (int)s_i1 && (int)s_j0 && (int)s_j1))
#else
            if (
                !(
                    static_cast<int>(s_i0) &&
                    static_cast<int>(s_i1) &&
                    static_cast<int>(s_j0) &&
                    static_cast<int>(s_j1)
                )
            )
#endif /* __cplusplus */
                continue;

            /* If the points P_i0 and P_i1 are on the opposite sides of the line
             * P_j0 P_j1 (allowing them to be on the line as well), and the
             * points P_j0 and P_j1 are on the opposite sides of the line P_i0
             * P_i1 (again, allowing the points to be on the line), the line
             * segments P_i0 P_i1 and P_j0 P_j1 are crossing.  If that is the
             * case, set the answer to `false` and break the `for`-loop. */
#if !defined(__cplusplus)
            if (
                !(
                    (int)s_i0 * (int)s_i1 == 1 ||
                    (int)s_j0 * (int)s_j1 == 1
                )
            )
#else
            if (
                !(
                    static_cast<int>(s_i0) * static_cast<int>(s_i1) == 1 ||
                    static_cast<int>(s_j0) * static_cast<int>(s_j1) == 1
                )
            )
#endif /* __cplusplus */
            {
                /* Set the answer to `false`. */
                answer = false;

                /* Break the `for`-loop. */
                break;
            }
        }
    }

    /* Return the answer. */
    return answer;
}

/**
 * Simplify and check if an array of points is an ordered set of true vertices
 * of a polygon.
 *
 * The function is a wrapper around the functions `simplify_polygon` and
 * `check_polygon`.
 *
 * The given array is mutated in the `simplify_polygon` function.
 *
 * @param n
 *     Pointer to the variable defining the (maximal) number of points.  The
 *     number `*n` is updated after the simplification (if the number is
 *     reduced, the value of the variable pointed at by `n` is set to the new
 *     number of points).
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function `simplify_polygon`.
 *
 * @return
 *     If `n` is not a null-pointer, the value returned by the function
 *     `check_polygon` after the simplification done by the function
 *     `simplify_polygon`; otherwise value `false`.
 *
 * @see simplify_polygon
 * @see check_polygon
 *
 */
#if !defined(__cplusplus)
bool simplify_check_polygon (size_t* n, real_t* P)
#else
bool simplify_check_polygon (::size_t* n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Answer. */
    bool answer;

    /* INITIALISATION OF VARIABLES */

    /* Answer. */
    answer = false;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If `n` is a null-pointer, break the `do while`-loop. */
        if (!n)
            break;

        /* If the pointer `P` is a null-pointer, set the number `*n` to 0. */
        if (!P)
            *n = 0U;

        /* Simplify the array and update the number `*n`. */
#if !defined(__cplusplus)
        *n = (size_t)(simplify_polygon(*n, P) - P) / 2U;
#else
        *n = static_cast<size_t>(simplify_polygon(*n, P) - P) / 2U;
#endif /* __cplusplus */

        /* Check for the polygon and update the answer. */
        answer = check_polygon(*n, P);
    }
    while (false);

    /* Return the answer. */
    return answer;
}

/**
 * Compute the diameter of a finite set of points.
 *
 * The given array is not mutated in the function.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.
 *
 * @param sq
 *     If `false`, the true diameter is returned;  otherwise the squared
 *     diameter is returned.  To get the squared diameter, it is more efficient
 *     to pass a non-false value as `sq` than to square the result after calling
 *     the function with `sq` set to `false` as non-squared diameter is computed
 *     from the squared diameter merely using the function `rsqrt`.
 *
 * @return
 *     Maximal Euclidean distance between the points (squared if
 *     `sq` != `false`).
 *
 * @see rsqrt
 *
 */
#if !defined(__cplusplus)
real_t diameter_polygon (size_t n, const real_t* P, bool sq)
#else
real_t diameter_polygon (::size_t n, const real_t* P, bool sq)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
#else
    ::size_t i;
    ::size_t j;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    const real_t* x_0;
    const real_t* y_0;
    const real_t* x_1;
    const real_t* y_1;

    /* Differences in coordinates. */
    real_t dx;
    real_t dy;

    /* Maximal found distance and an arbitrary distance (most probably
     * squared). */
    real_t D;
    real_t d;

    /* INITIALISATION OF VARIABLES */

    /* Iteration indices. */
    i = 0U;
    j = 0U;

    /* Auxiliary pointers to coordinates of points. */
    x_0 = P;
    y_0 = x_0 + 1U;
    x_1 = P;
    y_1 = x_1 + 1U;

    /* Differences in coordinates. */
    dx = 0.0;
    dy = 0.0;

    /* Maximal found Euclidean distance and an arbitrary Euclidean distance
     * (most probably squared). */
    D = 0.0;
    d = 0.0;

    /* ALGORITHM */

    /* If the pointer `P` is a null-pointer, set the number `n` to 0. */
    if (!P)
        n = 0U;

    /* Iterate over the points. */
    for (i = 0U; i < n; ++i)
    {
        /* Extract the coordinates of the `i`-th point. */
        x_0 = P + 2U * i;
        y_0 = x_0 + 1U;

        /* Iterate over the remaining points and check the distances from the
         * `i`-th point. */
        for (j = i + 1U; j < n; ++j)
        {
            /* Extract the coordinates of the `j`-th point. */
            x_1 = P + 2U * j;
            y_1 = x_1 + 1U;

            /* Compute the differences in coordinates of the `i`-th and the
             * `j`-th points. */
            dx = *x_1 - *x_0;
            dy = *y_1 - *y_0;

            /* Compute the sqared Euclidean distance between the `i`-th and the
             * `j`-th points. */
            d = dx * dx + dy * dy;

            /* If the current distance is larger than the distance `D`, set the
             * distance `D` to the value of the current distance `d`. */
            if (d > D)
                D = d;
        }
    }

    /* Return the diameter of the set; squared or not according to value of the
     * parameter `sq`. */
    return sq ? D : rsqrt(D);
}

/**
 * Standardise an array of points by dividing all the coordinates by the
 * diameter of the set of the points.
 *
 * If the diameter `d` of the set of the points is not 0, all the coordinates
 * are divided by `d`; otherwise all the coordinates are set to (0, 0).
 *
 * The function mutates the given array.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 */
#if !defined(__cplusplus)
void standardise_polygon (size_t n, real_t* P)
#else
void standardise_polygon (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* INITIALISATION OF VARIABLES */

    /* Diameter. */
    real_t d;

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* INITIALISATION OF VARIABLES */

    /* Diameter. */
    d = 0.0;

    /* Iteration index. */
    i = 0U;

    /* ALGORITHM */

    /* If the pointer `P` is a null-pointer, set the number `n` to 0. */
    if (!P)
        n = 0U;

    /* Compute the diameter of the set of the points. */
    d = diameter_polygon(n, P, false);

    /* Update the points' coordinates. */

    /* If the diameter is 0, iterate over the points and set their coordinates
     * to (0, 0). */
    if (d == 0)
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) = 0.0;
    /* Otherwise iterate over the points and divide their coordinates by `d`. */
    else
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) /= d;
}

/**
 * Describe a polygon defined by an array of its vertices by computing the
 * lengths of its edges and outer angles.
 *
 * The lengths of the edges of the polygon are computed using the `rsqrt`
 * function and the outer angles are computed using the `racos` function.  The
 * outer angles' values are from the interval (-pi, pi].
 *
 * The memory for the arrays of the edges' lengths and the outer angles must be
 * preallocated.  If either of the arguments passed is a null-pointer, no effect
 * will be made.  If the memory locations of either of the three arrays overlap,
 * the results will be unexpected.
 *
 * The results may also be unexpected if the array of points is not an array of
 * coordinates of true vertices of a polygon in the mathematically positive
 * order.  To assure this, simplify the polygon, check it if it really is a
 * polygon and reorder the vertices using the `simplify_polygon`,
 * `check_polygon` (or `simplify_check_polygon`) and
 * `correct_polygon_orientation` functions.
 *
 * The array `P` is not mutated in the function, but the arrays `l` and `phi`
 * are.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.  The points
 *     represent the vertices of the polygon.
 *
 * @param l
 *     Array of the edges' lengths of size at least 2 * `n`.  The array is
 *     filled as
 *     {|(x_0, y_0), (x_1, y_1)|, |(x_1, y_1), (x_2, y_2)|, ...,
 *     |(x_n_minus_2, y_n_minus_2), (x_n_minus_1, y_n_minus_1)|,
 *     |(x_n_minus_1, y_n_minus_1), (x_0, y_0)|}, where |(x_A, y_A), (x_B, y_B)|
 *     is the distance from the point A = (x_A, y_A) to the point
 *     B = (x_B, y_B).
 *
 *     Caution: the array is mutated in the function.
 *
 * @param phi
 *     Array of the outer angles of size at least 2 * `n`.  The array is filled
 *     as `{phi_1, phi_2, ..., phi_n_minus_2, phi_n_minus_1, phi_0}`, where
 *     `phi_i` is the outer angle at the `i`-th vertex.
 *
 *     Caution: the array is mutated in the function.
 *
 * @see simplify_polygon
 * @see check_polygon
 * @see simplify_check_polygon
 * @see correct_polygon_orientation
 *
 */
void describe_polygon (size_t n, const real_t* P, real_t* l, real_t* phi)
{
    /* DECLARATION OF VARIABLES */

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
    size_t k;
#else
    ::size_t i;
    ::size_t j;
    ::size_t k;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    const real_t* x_i;
    const real_t* y_i;
    const real_t* x_j;
    const real_t* y_j;
    const real_t* x_k;
    const real_t* y_k;

    /* Differences in coordinates. */
    real_t dx_i;
    real_t dy_i;
    real_t dx_j;
    real_t dy_j;

    /* Auxiliary pointers to lengths of edges. */
    real_t* l_i;
    real_t* l_j;

    /* INITIALISATION OF VARIABLES */

    /* Iteration indices. */
    i = 0U;
    j = 0U;
    k = 0U;

    /* Auxiliary pointers to coordinates of points. */
    x_i = P;
    y_i = x_i + 1U;
    x_j = P;
    y_j = x_i + 1U;
    x_k = P;
    y_k = x_i + 1U;

    /* Differences in coordinates. */
    dx_i = 0.0;
    dy_i = 0.0;
    dx_j = 0.0;
    dy_j = 0.0;

    /* Auxiliary pointers to lengths of edges. */
    l_i = l;
    l_j = l;

    /* ALGORITHM */

    /* If either of the pointers `P`, `l` and `phi` is a null-pointer, set the
     * number `n` to 0. */
    if (!(P && l && phi))
        n = 0U;

    /* Initialise the arrays `l` and `phi` to zeros. */
#if !defined(__cplusplus)
    memset(l, 0, n * sizeof *l);
    memset(phi, 0, n * sizeof *phi);
#else
    ::memset(l, 0, n * sizeof *l);
    ::memset(phi, 0, n * sizeof *phi);
#endif /* __cplusplus */

    /* Iterate over the points and compute the lengths of edges and the outer
     * angles. */
    for (i = 0U; i < n; ++i)
    {
        /* Compute the indices of the next two points. */
        j = incmod(i, n);
        k = incmod(j, n);

        /* Ektract the coordinates of the `i`-th, the `j`-th and the `k`-th
         * points---points `P_i`, `P_j` and `P_k` respectively. */
        x_i = P + 2U * i;
        y_i = x_i + 1U;
        x_j = P + 2U * j;
        y_j = x_j + 1U;
        x_k = P + 2U * k;
        y_k = x_k + 1U;

        /* Compute the diferences in coordinates of points P_i and P_j, and
         * points P_j and P_k. */
        dx_i = *x_j - *x_i;
        dy_i = *y_j - *y_i;
        dx_j = *x_k - *x_j;
        dy_j = *y_k - *y_j;

        /* Extract the lengths of edges P_i P_j and P_j P_k. */
        l_i = l + i;
        l_j = l + j;

        /* If the lengths of edge P_i P_j is currently set to 0, compute it; do
         * the same with the edge P_j P_k if its length is set to 0. */
        if (*l_i == 0.0)
            *l_i = rsqrt(dx_i * dx_i + dy_i * dy_i);
        if (*l_j == 0.0)
            *l_j = rsqrt(dx_j * dx_j + dy_j * dy_j);

        /* Compute the angle at the point P_j and save its value on the `i`-th
         * place in the array `phi`. */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
        *(phi + i) = (
            rsign(dx_i * (*y_k - *y_i) - (*x_k - *x_i) * dy_i) == minus ?
                -racos((dx_i * dx_j + dy_i * dy_j) / (*l_i * *l_j)) :
                racos((dx_i * dx_j + dy_i * dy_j) / (*l_i * *l_j))
        );
#else /* __cplusplus */
        *(phi + i) = (
            rsign(dx_i * (*y_k - *y_i) - (*x_k - *x_i) * dy_i) ==
                sign_t::minus ?
                -racos((dx_i * dx_j + dy_i * dy_j) / (*l_i * *l_j)) :
                racos((dx_i * dx_j + dy_i * dy_j) / (*l_i * *l_j))
        );
#endif /* __cplusplus */
    }
}

#endif /* __POLYGON_H__INCLUDED */

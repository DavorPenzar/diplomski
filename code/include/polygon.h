/**
 * Functions for generating and checking polygons.
 *
 * This file is part of Davor Penzar's master thesis programing.
 *
 * @author Davor Penzar <davor.penzar@gmail.com>
 * @version 1.0
 * @package polygon
 *
 */

/* Check if the header has already been imported. */
#if !(defined(__POLYGON_H__INCLUDED) && (__POLYGON_H__INCLUDED) == 1)

/* Undefine __POLYGON_H__INCLUDED if it has already been defined. */
#if defined(__POLYGON_H__INCLUDED)
#undef __POLYGON_H__INCLUDED
#endif /* __POLYGON_H__INCLUDED */

/* Define __POLYGON_H__INCLUDED as 1. */
#define __POLYGON_H__INCLUDED 1

/* Import standard library headers. */

#if !defined(__cplusplus)

#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#else

#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <exception>
#include <iomanip>
#include <ios>
#include <memory>
#include <new>
#include <ostream>
#include <stdexcept>
#include <string>

#endif /* __cplusplus */

/* Import package headers. */
#include "array.h"
#include "boolean.h"
#include "numeric.h"

/* Check if the macro _DGESVD_DRIVER is properly defined. */
#if !(defined(_DGESVD_DRIVER) && (_DGESVD_DRIVER) == 1)

/* If the macro _DGESVD_DRIVER has been defined unproperly, undefine it. */
#if defined(_DGESVD_DRIVER)
#undef _DGESVD_DRIVER
#endif /* _DGESVD_DRIVER */

/* Define the macro _DGESVD_DRIVER as 1. */
#define _DGESVD_DRIVER 1

#endif /* _DGESVD_DRIVER */

/* Check if the macro _DGESDD_DRIVER is properly defined. */
#if !(defined(_DGESDD_DRIVER) && (_DGESDD_DRIVER) == 2)

/* If the macro _DGESDD_DRIVER has been defined unproperly, undefine it. */
#if defined(_DGESDD_DRIVER)
#undef _DGESDD_DRIVER
#endif /* _DGESDD_DRIVER */

/* Define the macro _DGESDD_DRIVER as 2. */
#define _DGESDD_DRIVER 2

#endif /* _DGESDD_DRIVER */

/* Import the SVD driver. */
#if defined(_USE_SVD_DRIVER)
#if (_USE_SVD_DRIVER) == (_DGESVD_DRIVER)
extern void dgesvd_ (
    char* JOBU,
    char* JOBVT,
    int* M,
    int* N,
    double* A,
    int* LDA,
    double* S,
    double* U,
    int* LDU,
    double* VT,
    int* LDVT,
    double* WORK,
    int* LWORK,
    int* INFO
);
#elif (_USE_SVD_DRIVER) == (_DGESDD_DRIVER)
extern void dgesdd_ (
    char* JOBZ,
    int* M,
    int* N,
    double* A,
    int* LDA,
    double* S,
    double* U,
    int* LDU,
    double* VT,
    int* LDVT,
    double* WORK,
    int* LWORK,
    int* IWORK,
    int* INFO
);
#endif /* _USE_SVD_DRIVER */
#endif /* _USE_SVD_DRIVER */

/**
 * Generate points in a plane.
 *
 * Use this function to generate a polygon if it is likely (or even certain)
 * that the generated array of points will be a polygon (if additional checkings
 * during the generating process is unnecessary) using the `generator` function.
 * Otherwise use the `smart_random_polygon` function.
 *
 * Caution: the function may fail if memory must be allocated for the resulting
 * array, but the allocation failed.  If that happens, the null-pointer is
 * returned.  Exceptions thrown by failed memory allocation in C++ are not
 * caught.
 *
 * @param n
 *     Number of points to generate.
 *
 * @param P
 *     Pointer to the coordinates of the first point in the array of size at
 *     least 2 * `n`.
 *
 *     If a null-pointer is passed, the memory is dynamically allocated using
 *     the `malloc` function in C and by calling the `new[]` operator in C++.
 *
 * @param generator
 *     Function to generate coordinates of a point.  The x-coordinate of the
 *     `i`-th point is generated by calling `generate(i, 0)`, and the
 *     y-coordinate of the point is generated by calling `generate(i, 1)`.
 *
 * @return
 *     Array of points of size 2 * `n` if `generator` is not a null-pointer;
 *     otherwise a null-pointer is returned.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  The
 *     points do not have to be true vertices---use `simplify_polygon` to
 *     exclude unnecessary points.  Even if the points are true vertices, they
 *     may not define a true polygon---use `check_polygon` to check for this.
 *     To be more sure of generating a true polygon, use `smart_random_polygon`.
 *
 *     The x-coordinates are generated by calling the `generator` function.  The
 *     coordinates are generated in the order: x_0, y_0, x_1, y_1, ...,
 *     x_n_minus_1, y_n_minus_1.
 *
 * @see malloc
 * @see simplify_polygon
 * @see check_polygon
 * @see smart_random_polygon
 *
 */
#if !defined(__cplusplus)
real_t* random_polygon (
    size_t n,
    real_t* P,
    real_t (* generator) (size_t, size_t)
)
#else
real_t* random_polygon (
    ::size_t n,
    real_t* P,
    real_t (* generator) (::size_t, ::size_t)
)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* INITIALISATION OF VARIABLES */

    /* Iteration index. */
    i = 0U;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If `n` == 0 or if `generator` is a null-pointer, break the
         * `do while`-loop. */
        if (!(n && generator))
            break;

        /* Allocate the memory for the array `P` if necessary. */
        if (!P)
#if !defined(__cplusplus)
            P = (real_t*)malloc((n << 1U) * sizeof *P);
#else
            P = new real_t[n << 1U];
#endif /* __cplusplus */

        /* If the memory allocation has failed, break the `do while`-loop. */
        if (!P)
            break;

        /* Initialise the array of points to zeros. */
#if !defined(__cplusplus)
        memset(P, 0, (n << 1U) * sizeof *P);
#else
        ::memset(P, 0, (n << 1U) * sizeof *P);
#endif /* __cplusplus */

        /* Fill the array with random coordinates. */
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) = (*generator)(i >> 1U, i & 1U);
    }
    while (false);

    /* Return the generated array of points. */
    return P;
}

/**
 * Generate points in a plane so that no two line segments intersect.
 *
 * Use this function to generate a polygon if it is not likely that the
 * generated array of points will be a polygon without additional checkings and
 * corrections (tries until satisfaction) using the `generator` function.
 * Otherwise use the `random_polygon` function.
 *
 * Caution: the function may fail if memory must be allocated for the resulting
 * array, but the allocation failed.  If that happens, the null-pointer is
 * returned.  Exceptions thrown by failed memory allocation in C++ are not
 * caught.
 *
 * @param n
 *     Number of points to generate.
 *
 * @param P
 *     Pointer to the coordinates of the first point in the array of size at
 *     least 2 * `n`.
 *
 *     If a null-pointer is passed, the memory is dynamically allocated using
 *     the `malloc` function in C and by calling the `new[]` operator in C++.
 *
 * @param generator
 *     Function to generate coordinates of a point.  The x-coordinate of the
 *     `i`-th point is generated by calling `generate(i, 0)`, and the
 *     y-coordinate of the point is generated by calling `generate(i, 1)`.
 *
 * @param out_iter_max
 *     Maximal number of outer iterations (attempts of generating a complete
 *     array satisfying the requirements).
 *
 * @param in_iter_max
 *     Maximal number of inner iterations (attempts of generating a single
 *     point satisfying the requirements).  At each new point the number of
 *     inner iterations starts at 0, but, if the maximal number of inner
 *     iterations has been exhausted on a single point, the algorithm
 *     immediately proceeds to the next outer iteration (if the maximal number
 *     of outer iterations has not been exhausted yet).
 *
 * @return
 *     Array of points of size 2 * `n` if `generator` is not a null-pointer;
 *     otherwise a null-pointer is returned.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Unlike
 *     the function `random_polygon`, it is guaranteed that no two disjoint
 *     pairs of consecutive points are end-points of intersecting linesegments,
 *     unless they share a common end-point in which case all the "edges"
 *     between them are actually the shared end-point.  The points do not have
 *     to be true vertices---use the function `simplify_polygon` to exclude
 *     unnecessary points.  Even if the points are true vertices, they may not
 *     define a true polygon---use the function `check_polygon` to check for
 *     this.  However, it is more likely that this function will generate a true
 *     polygon (simplifiable or not) than the function `random_polygon` if the
 *     `generator` function generates points uniformly distributed.
 *
 *     The x-coordinates are generated by calling the `generator` function.  The
 *     coordinates are generated in the order: x_0, y_0, x_1, y_1, ...,
 *     x_n_minus_1, y_n_minus_1.  Coordinates of the same point are being
 *     generated until it satisfies the requirements.  In each outer iteration
 *     all points are generated (no value is passed to the next iteration).
 *
 *     If the requirements could not have been satisfied after exhausting the
 *     maximal numbers of iterations, all the points are set to coordinates
 *     (`lambda`, `lambda`).  However, if a null-pointer was passed as the
 *     argument `P`, a null-pointer will be returned as well.
 *
 *
 * @see malloc
 * @see simplify_polygon
 * @see check_polygon
 * @see random_polygon
 *
 */
#if !defined(__cplusplus)
real_t* smart_random_polygon (
    size_t n,
    real_t* P,
    real_t (* generator) (size_t, size_t),
    size_t out_iter_max,
    size_t in_iter_max
)
#else
real_t* smart_random_polygon (
    ::size_t n,
    real_t* P,
    real_t (* generator) (::size_t, ::size_t),
    ::size_t out_iter_max,
    ::size_t in_iter_max
)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Flag for checking if the given pointer is a null-pointer. */
    bool P_null;

    /* Flag for checking the requirements. */
    bool bad;

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t r;
    size_t i;
    size_t j;
#else
    ::size_t r;
    ::size_t i;
    ::size_t j;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_i0;
    real_t* y_i0;
    real_t* x_i1;
    real_t* y_i1;
    real_t* x_j0;
    real_t* y_j0;
    real_t* x_j1;
    real_t* y_j1;

    /* Differences in coordinates. */
    real_t dx_i;
    real_t dy_i;
    real_t dx_j;
    real_t dy_j;

    /* Signs of expressions of lines evaluated at certain points. */
    sign_t s_i0;
    sign_t s_i1;
    sign_t s_j0;
    sign_t s_j1;

    /* INITIALISATION OF VARIABLES */

    /* Flags for checking if the given pointer is a null-pointer and for
     * checking the requirements. */
    P_null = false;
    bad = false;

    /* Iteration indices. */
    r = 0U;
    i = 0U;
    j = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_i0 = (real_t*)(NULL);
    y_i0 = (real_t*)(NULL);
    x_i1 = (real_t*)(NULL);
    y_i1 = (real_t*)(NULL);
    x_j0 = (real_t*)(NULL);
    y_j0 = (real_t*)(NULL);
    x_j1 = (real_t*)(NULL);
    y_j1 = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_i0 = reinterpret_cast<real_t*>(NULL);
    y_i0 = reinterpret_cast<real_t*>(NULL);
    x_i1 = reinterpret_cast<real_t*>(NULL);
    y_i1 = reinterpret_cast<real_t*>(NULL);
    x_j0 = reinterpret_cast<real_t*>(NULL);
    y_j0 = reinterpret_cast<real_t*>(NULL);
    x_j1 = reinterpret_cast<real_t*>(NULL);
    y_j1 = reinterpret_cast<real_t*>(NULL);
#else
    x_i0 = nullptr;
    y_i0 = nullptr;
    x_i1 = nullptr;
    y_i1 = nullptr;
    x_j0 = nullptr;
    y_j0 = nullptr;
    x_j1 = nullptr;
    y_j1 = nullptr;
#endif /* __cplusplus */

    /* Differences in coordinates. */
    dx_i = 0.0;
    dy_i = 0.0;
    dx_j = 0.0;
    dy_j = 0.0;

    /* Signs of expressions of lines evaluated at certain points. */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
    s_i0 = zero;
    s_i1 = zero;
    s_j0 = zero;
    s_j1 = zero;
#else
    s_i0 = sign_t::zero;
    s_j1 = sign_t::zero;
    s_i0 = sign_t::zero;
    s_j1 = sign_t::zero;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* If the given pointer `P` is a null-pointer, set the flag for checking it
     * to `true`. */
    if (!P)
        P_null = true;

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If `n` == 0, break the `do while`-loop. */
        if (!n)
            break;

        /* Allocate memory for the array `P` if necessary. */
        if (P_null)
#if !defined(__cplusplus)
            P = (real_t*)malloc((n << 1U) * sizeof *P);
#else
            P = new real_t[n << 1U];
#endif /* __cplusplus */

        /* If the memory allocation has failed, break the `do while`-loop. */
        if (!P)
            break;

        /* Initialise the array of points to zeros. */
#if !defined(__cplusplus)
        memset(P, 0, (n << 1U) * sizeof *P);
#else
        ::memset(P, 0, (n << 1U) * sizeof *P);
#endif /* __cplusplus */

        /* If the maximal number of outer and inner iterations is 0, set all
         * values in the array to `lambda` and break the `do while`-loop. */
        if (!(out_iter_max && in_iter_max))
        {
            /* If the given pointer `P` was a null-pointer, deallocate the
             * memory allocated for the array. */
            if (P_null)
            {
#if !defined(__cplusplus)
                free(P);
                P = (real_t*)(NULL);
#else
                delete[] P;
#if (__cplusplus) < 201103L
                P = reinterpret_cast<real_t*>(NULL);
#else
                P = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */
            }
            /* Otherwise set all the values in the array to `lambda`. */
            else
                for (i = 0U; (i >> 1U) < n; ++i)
                    *(P + i) = lambda;

            /* Break the `do while`-loop. */
            break;
        }

        /* Generate random points until the requirements are satisfied or unitl
         * the maximal number of outer iterations is exhausted. */
        do
        {
            /* Initialise the array of points to zeros. */
#if !defined(__cplusplus)
            memset(P, 0, (n << 1U) * sizeof *P);
#else
            ::memset(P, 0, (n << 1U) * sizeof *P);
#endif /* __cplusplus */

            /* Extract the coordinates of the first point---point P_i0. */
            x_i0 = P;
            y_i0 = x_i0 + 1U;

            /* Generate random coordinates for the point P_i0. */
            *x_i0 = (*generator)(0U, 0U);
            *y_i0 = (*generator)(0U, 1U);

            /* If `n` == 1, break the `do while`-loop. */
            if (n == 1U)
                break;

            /* Extract the coordinates of the second point---point P_i1. */
            x_i1 = P + 2U;
            y_i1 = x_i1 + 1U;

            /* Generate random coordinates for the point P_i1. */
            *x_i1 = (*generator)(1U, 0U);
            *y_i1 = (*generator)(1U, 1U);

            /* Iterate over the rest of the points. */
            for (i = 2U; i < n; ++i)
            {
                /* Set the point P_i0 to point P_i1. */
                x_i0 = x_i1;
                y_i0 = y_i1;

                /* Extract the coordinates of the `i`-th point---point P_i1. */
                x_i1 = P + (i << 1U);
                y_i1 = x_i1 + 1U;

                /* Set the flag `bad` to `true` (assume the requirements are not
                 * satisfied). */
                bad = true;

                /* Generate random coordinates for the point P_i1 until the
                 * requirements are satisfied or until the maximal number of
                 * inner iterations is exhausted. */
                for (r = 0U; bad && r < in_iter_max; ++r)
                {
                    /* Set the flag `bad` to `false` (assume the requirements
                     * are satisfied). */
                    bad = false;

                    /* Generate random coordinates for the point P_i1. */
                    *x_i1 = (*generator)(i, 0U);
                    *y_i1 = (*generator)(i, 1U);

                    /* Compute the differences in coordinates of points P_i0 and
                     * P_i1. */
                    dx_i = *x_i1 - *x_i0;
                    dy_i = *y_i1 - *y_i0;

                    /* Iterate over all the previous points and check if any
                     * edge intersects with the line segment P_i0 P_i1. */
                    for (j = 0U; j + 1U < i; ++j)
                    {
                        /* Extract the coordinates of the `j`-th point---point
                         * P_j0. */
                        x_j0 = P + (j << 1U);
                        y_j0 = x_j0 + 1U;

                        /* Extract the coordinates of the ((`j` + 1) mod n)-th
                         * point---point P_j1. */
                        x_j1 = P + (incmod(j, n) << 1U);
                        y_j1 = x_j1 + 1U;

                        /* If the point P_j0 is in fact point P_i1 or the point
                         * P_j1 is in fact point Pi0, break the `for`-loop. */
                        if (
                            (x_j0 == x_i1 && y_j0 == y_i1) ||
                            (x_j1 == x_i0 && y_j1 == y_i0)
                        )
                            break;

                        /* Compute the differences in coordinates of points P_j0
                         * and P_j1. */
                        dx_j = *x_j1 - *x_j0;
                        dy_j = *y_j1 - *y_j0;

                        /* Compute the signs of expressions of the line
                         * P_j0 P_j1 evaluated at points P_i0 and P_i1, and of
                         * the line P_i0 P_i1 evaluated at points P_j0 and
                         * P_j1. */
                        s_i0 = rsign(
                            dx_j * (*y_i0 - *y_j0) - dy_j * (*x_i0 - *x_j0)
                        );
                        s_i1 = rsign(
                            dx_j * (*y_i1 - *y_j0) - dy_j * (*x_i1 - *x_j0)
                        );
                        s_j0 = rsign(
                            dx_i * (*y_j0 - *y_i0) - dy_i * (*x_j0 - *x_i0)
                        );
                        s_j1 = rsign(
                            dx_i * (*y_j1 - *y_i0) - dy_i * (*x_j1 - *x_i0)
                        );

                        /* If all four points are on the same line, continue to
                         * the next iteration (next points P_j0 and P_j1). */
#if !defined(__cplusplus)
                        if (!((int)s_i0 && (int)s_i1 && (int)s_j0 && (int)s_j1))
#else
                        if (
                            !(
                                static_cast<int>(s_i0) &&
                                static_cast<int>(s_i1) &&
                                static_cast<int>(s_j0) &&
                                static_cast<int>(s_j1)
                            )
                        )
#endif /* __cplusplus */
                            continue;

                        /* If the points P_i0 and P_i1 are on the opposite sides
                         * of the line P_j0 P_j1 (allowing them to be on the
                         * line as well), and the points P_j0 and P_j1 are on
                         * the opposite sides of the line P_i0 P_i1 (again,
                         * allowing the points to be on the line), the line
                         * segments P_i0 P_i1 and P_j0 P_j1 are crossing.  If
                         * that is the case, set the flag `bad` to `true` and
                         * break the `for`-loop. */
#if !defined(__cplusplus)
                        if (
                            !(
                                (int)s_i0 * (int)s_i1 == 1 ||
                                (int)s_j0 * (int)s_j1 == 1
                            )
                        )
#else
                        if (
                            !(
                                static_cast<int>(s_i0) *
                                    static_cast<int>(s_i1) ==
                                    1 ||
                                static_cast<int>(s_j0) *
                                    static_cast<int>(s_j1) ==
                                    1
                            )
                        )
#endif /* __cplusplus */
                        {
                            /* Set the flag `bad` to `true`. */
                            bad = true;

                            /* Break the `for`-loop. */
                            break;
                        }
                    }
                }

                /* If a "good" point could not be generated in `in_iter_max`
                 * iterations, break the `for`-loop. */
                if (bad)
                    break;
            }

            /* If all the points have been succesfully generated, break the
             * `do while`-loop. */
            if (!bad)
                break;

            /* Set all the values in the array to `lambda` (annul all the
             * points). */
            for (j = 0U; (j >> 1U) < n; ++j)
                *(P + j) = lambda;
        }
        while (--out_iter_max);

        /* If all the outer itterations have been exhausted and the original
         * pointer `P` was a null-pointer, free the memory for the array. */
        if (!out_iter_max && P_null)
        {
            /* Clear the memory in the array. */
#if !defined(__cplusplus)
            memset(P, 0, (n << 1U) * sizeof *P);
#else
            ::memset(P, 0, (n << 1U) * sizeof *P);
#endif /* __cplusplus */

            /* Deallocate the memory. */
#if !defined(__cplusplus)
            free(P);
            P = (real_t*)(NULL);
#else
            delete[] P;
#if (__cplusplus) < 201103L
            P = reinterpret_cast<real_t*>(NULL);
#else
            P = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */
        }
    }
    while (false);

    /* Return the generated array of points. */
    return P;
}

/**
 * Simplify an array of points into an array that could be easily checked if it
 * represents an ordered set of true vertices of a polygon.
 *
 * If a point in the given array of points is on the line segment between its
 * neighbours, it is deleted.  Note that the first and the last points are
 * neigbouring (the array is cyclical).
 *
 * The function mutates the given array.  All the points that are kept will be
 * at the beginning of the array, and all the deleted points will be set to
 * coordinates (`lambda`, `lambda`).  The first point in the array after calling
 * the function may be different than the first point in the array before
 * calling the function, but the cyclical order of the points is preserved.  No
 * new points are added in the array, some points are only deleted.
 *
 * Caution: the function may fail if memory cannot be allocated for some
 * auxiliary additional arrays.  If that happens, the polygon may not be
 * fully simplified.  Exceptions thrown by failed memory allocation in C++ are
 * not caught.
 *
 * @param n
 *     Maximal number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 * @return
 *     Pointer to the end of the array of points `P` after deleting the
 *     unnecessary points.  All the values in the given array after the position
 *     that is returned until the position 2 * `n` are filled with the value
 *     `lambda`.
 *
 */
#if !defined(__cplusplus)
real_t* simplify_polygon (size_t n, real_t* P)
#else
real_t* simplify_polygon (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Auxiliary number of points. */
#if !defined(__cplusplus)
    size_t m;
#else
    ::size_t m;
#endif /* __cplusplus */

    /* Auxiliary array of points. */
    real_t* Q;

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
    size_t k;
#else
    ::size_t i;
    ::size_t j;
    ::size_t k;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_0;
    real_t* y_0;
    real_t* x_1;
    real_t* y_1;
    real_t* x_2;
    real_t* y_2;

    /* Differences in coordinates. */
    real_t dx_0_1;
    real_t dy_0_1;
    real_t dx_0_2;
    real_t dy_0_2;

    /* Signs of differences in coordinates. */
    sign_t sdx_1;
    sign_t sdy_1;
    sign_t sdx_2;
    sign_t sdy_2;

    /* INITIALISATION OF VARIABLES */

    /* Auxiliary number of points. */
    m = n;

    /* Auxiliary array of points. */
#if !defined(__cplusplus)
    Q = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    Q = reinterpret_cast<real_t*>(NULL);
#else
    Q = nullptr;
#endif /* __cplusplus */

    /* Iteration indices. */
    i = 0U;
    j = 0U;
    k = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_0 = (real_t*)(NULL);
    y_0 = (real_t*)(NULL);
    x_1 = (real_t*)(NULL);
    y_1 = (real_t*)(NULL);
    x_2 = (real_t*)(NULL);
    y_2 = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_0 = reinterpret_cast<real_t*>(NULL);
    y_0 = reinterpret_cast<real_t*>(NULL);
    x_1 = reinterpret_cast<real_t*>(NULL);
    y_1 = reinterpret_cast<real_t*>(NULL);
    x_2 = reinterpret_cast<real_t*>(NULL);
    y_2 = reinterpret_cast<real_t*>(NULL);
#else
    x_0 = nullptr;
    y_0 = nullptr;
    x_1 = nullptr;
    y_1 = nullptr;
    x_2 = nullptr;
    y_2 = nullptr;
#endif /* __cplusplus */

    /* Differences in coordinates. */
    dx_0_1 = 0.0;
    dy_0_1 = 0.0;
    dx_0_2 = 0.0;
    dy_0_2 = 0.0;

    /* Signs of differences in coordinates. */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
    sdx_1 = zero;
    sdy_1 = zero;
    sdx_2 = zero;
    sdy_2 = zero;
#else
    sdx_1 = sign_t::zero;
    sdy_1 = sign_t::zero;
    sdx_2 = sign_t::zero;
    sdy_2 = sign_t::zero;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* If the pointer `P` is a null-pointer, set the number `n` to 0. */
    if (!P)
        n = 0U;

    /* Iterate over the points. */
    for (i = 0U; i < n; ++i)
    {
        /* Extract the coordinates of the `i`-th point---point P_0. */
        x_0 = P + (i << 1U);
        y_0 = x_0 + 1U;

        /* Initialise the number `m` to the value of `n`. */
        m = n;

        /* Find the first point different from the `i`-th point---point P_1.
         * For all the skipped points, decrement the number `m`. */
        for (j = incmod(i, n); j != i; j = incmod(j, n))
        {
            /* Extract the coordinates of the `j`-th point. */
            x_1 = P + (j << 1U);
            y_1 = x_1 + 1U;

            /* If the `j`-th point is different from the point P_0, break the
             * `for`-loop. */
            if (*x_1 != *x_0 || *y_1 != *y_0)
                break;

            /* Decrement the number `m`. */
            --m;
        }

        /* If no different point P_1 is found, set the coordinates of the 0th
         * point to the coordinates of the point P_0, annul all the other points
         * and set the number `n` to 1. When done, break the `for`-loop. */
        if (j == i)
        {
            /* Set the coordinates of the 0-th point to the coordinates of the
             * point P_0. */
            *(P + 0U) = *x_0;
            *(P + 1U) = *y_0;

            /* Annul all points except the 0th point. */
            for (k = 2U; (k >> 1U) < n; ++k)
                *(P + k) = lambda;

            /* Set the number `n` to 1. */
            n = 1U;

            /* Break the `for`-loop. */
            break;
        }

        /* Compute the differences in coordinates of points P_0 and P_1. */
        dx_0_1 = *x_1 - *x_0;
        dy_0_1 = *y_1 - *y_0;

        /* Compute the signs of the differences in coordinates of points P_0 and
         * P_1. */
        sdx_1 = rsign(dx_0_1);
        sdy_1 = rsign(dy_0_1);

        /* Find the first point that is not on the directed line P_0 P_1 after
         * the point P_1---point P_2.  For all the skipped points, decrement the
         * number `m`. */
        for (k = incmod(j, n); k != i; k = incmod(k, n))
        {
            /* Extract the coordinates of the `j`-th point. */
            x_2 = P + (k << 1U);
            y_2 = x_2 + 1U;

            /* Compute the differences in coordinates of points P_0 and the
             * `k`-th point. */
            dx_0_2 = *x_2 - *x_0;
            dy_0_2 = *y_2 - *y_0;

            /* Compute the signs of the differences in coordinates of points P_1
             * and the `k`-th point. */
            sdx_2 = rsign(*x_2 - *x_1);
            sdy_2 = rsign(*y_2 - *y_1);

            /* If the `k`-th point is not on the line P_0 P_1 or if the signs of
             * the differences in coordinates of points P_1 and the `k`-th point
             * differ from the signs until the `k`-th point, the `k`-th point is
             * not on the directed line P_0 P_1 after the point P_1.  If that is
             * the case, break the `for`-loop. */
            if (
                !(
                    dx_0_1 * dy_0_2 == dy_0_1 * dx_0_2 &&
                    (sdx_2 == sdx_1 && sdy_2 == sdy_1)
                )
            )
                break;

            /* Set the coordinates of the point P_1 to (`x_2`, `y_2`). */
            x_1 = x_2;
            y_1 = y_2;

            /* Update the differences in coordinates of points P_0 and P_1. */
            dx_0_1 = dx_0_2;
            dy_0_1 = dy_0_2;

            /* Update the signs of the differences in the coordinates of the
             * preceeding two points. */
            sdx_1 = sdx_2;
            sdy_1 = sdy_2;

            /* Decrement the number `m`. */
            --m;
        }

        /* If no point was skipped, continue to the next iteration. */
        if (m == n)
            continue;

        /* Allocate memory for an auxiliary array of points. */
#if !defined(__cplusplus)
        Q = (real_t*)malloc((m << 1U) * sizeof *Q);
#else
        Q = new real_t[m << 1U];
#endif /* __cplusplus */

        /* If the memory allocation has failed, break the `for`-loop. */
        if (!Q)
            break;

        /* Initialise the auxiliary array of points to zeros. */
#if !defined(__cplusplus)
        memset(Q, 0, (m << 1U) * sizeof *Q);
#else
        ::memset(Q, 0, (m << 1U) * sizeof *Q);
#endif /* __cplusplus */

        /* Set the coordinates of the 0th point in the auxiliary array to
         * coordinates of the point P_0. */
        *(Q + 0U) = *x_0;
        *(Q + 1U) = *y_0;

        /* Decrement the index `k` in modular arithmetics modulo `n` so that it
         * points to the point P_1. */
        k = decmod(k, n);

        /* Copy the points from the point P_1 onward to the auxiliary array. */
        if (n + 1U - k < m)
        {
#if !defined(__cplusplus)
            memcpy(Q + 2U, P + (k << 1U), ((n - k) << 1U) * sizeof *P);
            memcpy(
                Q + ((n - k) << 1U) + 2U,
                P,
                (((m + k - n) << 1U) - 2U) * sizeof *P
            );
#else
            ::memcpy(Q + 2U, P + (k << 1U), ((n - k) << 1U) * sizeof *P);
            ::memcpy(
                Q + ((n - k) << 1U) + 2U,
                P,
                (((m + k - n) << 1U) - 2U) * sizeof *P
            );
#endif /* __cplusplus */
        }
        else
#if !defined(__cplusplus)
            memcpy(Q + 2U, P + (k << 1U), ((m << 1U) - 2U) * sizeof *P);
#else
            ::memcpy(Q + 2U, P + (k << 1U), ((m << 1U) - 2U) * sizeof *P);
#endif /* __cplusplus */

        /* Copy the content from the auxiliary array to the beginning of the
         * original array. */
#if !defined(__cplusplus)
        memcpy(P, Q, (m << 1U) * sizeof *Q);
#else
        ::memcpy(P, Q, (m << 1U) * sizeof *Q);
#endif /* __cplusplus */

        /* Annul all the points from the index `m` until the end in the original
         * array. */
        for (j = (m << 1U); (j >> 1U) < n; ++j)
            *(P + j) = lambda;

        /* Clear the memory in the auxiliary array. */
#if !defined(__cplusplus)
        memset(Q, 0, (m << 1U) * sizeof *Q);
#else
        ::memset(Q, 0, (m << 1U) * sizeof *Q);
#endif /* __cplusplus */

        /* Deallocate the memory allocated for the auxiliary array. */
#if !defined(__cplusplus)
        free(Q);
        Q = (real_t*)(NULL);
#else
        delete[] Q;
#if (__cplusplus) < 201103L
        Q = reinterpret_cast<real_t*>(NULL);
#else
        Q = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

        /* Update the number `n`---set it to the value of `m`. */
        n = m;

        /* Set the value of the index `i` to 0 (the point P_0 is now at the
         * beginning of the array `P`). */
        i = 0U;
    }

    /* Return the pointer to the first deleted point (if any). */
    return P + (n << 1U);
}

/**
 * Reorder an array of points into the conventional order.
 *
 * The conventional order of points is the following:
 *     1.  the first point is the point with the smallest second coordinate; if
 *         there are more than one points with the smallest second coordinate,
 *         the point with the largest first coordinate among them is the first
 *         point,
 *     2.  the points are listed counterclockwise.
 * No new points are added nor any of the points is deleted.  Note that the
 * first and the last points are neigbouring (the array is cyclical).
 *
 * After choosing the point to be the first, the clockwise order of the points
 * is checked by calculating the sign of the cross product of the last and the
 * first edge (the edge connecting the last point and the first point, and the
 * edge connecting the first point and the second point).  The order is
 * considered clockwise if the sign of the product is -1 (`minus`), otherwise
 * (even if the sign is 0 (`zero`)) the order is considered counterclockwise.
 *
 * The vertices of a polygon will be ordered conventionally if the
 * polygon has been simplified beforehand via the `simplify_polygon` function
 * and if the simplified polygon "has passed" the `check_polygon` function's
 * test.  However, even without the simplification the vertices may actually be
 * ordered conventionally.
 *
 * If any of the coordinates is NaN, the result may be unexpected.
 *
 * The given array is not mutated in the function.
 *
 * Caution: the function may fail if memory cannot be allocated for some
 * auxiliary additional arrays or if the memory allocation for the `flip`
 * function fails.  If any of that happens, the array may not be correctly
 * reordered.  Exceptions thrown by failed memory allocation in C++ are not
 * caught.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 * @see simplify_polygon
 * @see check_polygon
 * @see simplify_check_polygon
 *
 */
#if !defined(__cplusplus)
void correct_polygon_orientation (size_t n, real_t* P)
#else
void correct_polygon_orientation (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Auxiliary array of points. */
    real_t* Q;

    /* Index of the first point. */
#if !defined(__cplusplus)
    size_t v;
#else
    ::size_t v;
#endif /* __cplusplus */

    /* Iteration indices. */
    size_t i;
    size_t j;

    /* Pointers to coordinates of the first point. */
    real_t* x_v;
    real_t* y_v;

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_i;
    real_t* y_i;
    real_t* x_j;
    real_t* y_j;

    /* INITIALISATION OF VARIABLES */

    /* Auxiliary array of points. */
#if !defined(__cplusplus)
    Q = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    Q = reinterpret_cast<real_t*>(NULL);
#else
    Q = nullptr;
#endif /* __cplusplus */

    /* Index of the first point. */
    v = 0U;

    /* Iteration indices. */
    i = 0U;
    j = 0U;

    /* Pointers to coordinates of the first point. */
#if !defined(__cplusplus)
    x_v = (real_t*)(NULL);
    y_v = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_v = reinterpret_cast<real_t*>(NULL);
    y_v = reinterpret_cast<real_t*>(NULL);
#else
    x_v = nullptr;
    y_v = nullptr;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_i = (real_t*)(NULL);
    y_i = (real_t*)(NULL);
    x_j = (real_t*)(NULL);
    y_j = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_i = reinterpret_cast<real_t*>(NULL);
    y_i = reinterpret_cast<real_t*>(NULL);
    x_j = reinterpret_cast<real_t*>(NULL);
    y_j = reinterpret_cast<real_t*>(NULL);
#else
    x_i = nullptr;
    y_i = nullptr;
    x_j = nullptr;
    y_j = nullptr;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If the pointer `P` is a null-pointer, set the number `n` to 0 and
         * break the `do while`-loop. */
        if (!P)
        {
            /* Set the numbre `n` to 0. */
            n = 0U;

            /* Break the `do while`-loop. */
            break;
        }

        /* If the number of points is less than 2, break the `do while`-loop. */
        if (n < 2U)
            break;

        /* Initialise the index `v` to 0 and pointers to coordinates of the
         * point P_v to coordinates of the first point. */
        v = 0U;
        x_v = P;
        y_v = x_v + 1U;

        /* Iterate over the rest of the points to find the true first point
         * (when the array is correctly ordered). */
        for (i = 1U; i < n; ++i)
        {
            /* Extract the coordinates of the `i`-th point---point P_i. */
            x_i = P + (i << 1U);
            y_i = x_i + 1U;

            /* If the second coordinate of the point P_i is strictly smaller
             * than the second coordinate of the point P_v or if their second
             * coordinates are the same but the first coordinate of the point
             * P_i is strictly larger than the first coordinate of the point
             * P_v, update the index `v` to the value of `i` and the coordinates
             * of the point P_v to the coordinates of the point P_i. */
            if (*y_i < *y_v || (*y_i == *y_v && *x_v < *x_i))
            {
                /* Set the index `v` to the value of `i`. */
                v = i;

                /* Set the coordinates of the point P_v to the coordinates of
                 * the point P_i. */
                x_v = x_i;
                y_v = y_i;
            }
        }

        /* Compute the indices of the last and the second position in the
         * array. */
        i = n - 1U;
        j = 1U;

        /* Extract the (pointers to the) last and the second point in the
         * array. */
        x_i = P + (i << 1U);
        y_i = x_i + 1U;
        x_j = P + (j << 1U);
        y_j = x_j + 1U;

        /* If the index `v` is not 0 (if another point must be on the beginning
         * of the array), rotate the array. */
        if (v)
        {
            /* Allocate memory for the auxiliary array of points. */
#if !defined(__cplusplus)
            Q = (real_t*)malloc((n << 1U) * sizeof *Q);
#else
            Q = new real_t[n << 1U];
#endif /* __cplusplus */

            /* If the memory allocation has failed, break the
             * `do while`-loop. */
            if (!Q)
                break;

            /* Initialise the auxiliary array of points to zeros. */
#if !defined(__cplusplus)
            memset(Q, 0, (n << 1U) * sizeof *Q);
#else
            ::memset(Q, 0, (n << 1U) * sizeof *Q);
#endif /* __cplusplus */

            /* Copy the content from the original array to the auxiliary
             * array. */
#if !defined(__cplusplus)
            memcpy(Q, P + (v << 1U), ((n - v) << 1U) * sizeof *P);
            memcpy(Q + ((n - v) << 1U), P, (v << 1U) * sizeof *P);
#else
            ::memcpy(Q, P + (v << 1U), ((n - v) << 1U) * sizeof *P);
            ::memcpy(Q + ((n - v) << 1U), P, (v << 1U) * sizeof *P);
#endif /* __cplusplus */

            /* Copy the content from the auxiliary array to the original
             * array. */
#if !defined(__cplusplus)
            memcpy(P, Q, (n << 1U) * sizeof *Q);
#else
            ::memcpy(P, Q, (n << 1U) * sizeof *Q);
#endif /* __cplusplus */

            /* Clear the memory in the auxiliary array. */
#if !defined(__cplusplus)
            memset(Q, 0, (n << 1U) * sizeof *Q);
#else
            ::memset(Q, 0, (n << 1U) * sizeof *Q);
#endif /* __cplusplus */

            /* Deallocate the memory allocated for the auxiliary array. */
#if !defined(__cplusplus)
            free(Q);
            Q = (real_t*)(NULL);
#else
            delete[] Q;
#if (__cplusplus) < 201103L
            Q = reinterpret_cast<real_t*>(NULL);
#else
            Q = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

            /* Set the value of the index `v` to 0 (the point P_v is now
             * indeed at the beginning of the array `P`). */
            v = 0U;

            /* Set the coordinates of the point P_v to coordinates of the first
             * point in the array `P`. */
            x_v = P;
            y_v = x_v + 1U;
        }

        /* If the sign of the cross product of the last and the first edge is
         * -1 (`minus`), flip the rest of the array (excluding the first
         * element). */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
        if (
            rsign(
                (*x_v - *x_i) * (*y_j - *y_i) - (*x_j - *x_i) * (*y_v - *y_i)
            ) == minus
        )
#else
        if (
            rsign(
                (*x_v - *x_i) * (*y_j - *y_i) - (*x_j - *x_i) * (*y_v - *y_i)
            ) == sign_t::minus
        )
#endif /* __cplusplus */
            flip(P + 2U, n - 1U, (sizeof *P) << 1U);
    }
    while (false);
}

/**
 * Check if an array of points is an ordered set of true vertices of a polygon.
 *
 * If any three consecutive points are on the same line (or are the same point),
 * the array does not represent true vertices of a polygon in the order given.
 * Also, if any two pairs of neigbouring points such that the pairs do not have
 * a mutual point represent ending points of intersecting line segments (we
 * observe line segments between two points in a single pair, not between points
 * from different pairs), the points in the array are not ordered vertices of a
 * polygon.  Note that the first and the last points are neigbouring (the array
 * is cyclical).
 *
 * If the number of true vertices is indeed greater than 3 and no two edges
 * intersect except the neigbouring edges in their mutual end-points, the
 * returned value may be `false` if a point is given that is not a true vertex
 * (if it is on the line segment between its neigbouring points).  If the
 * number of true vertices is allowed to be less than `n`, it is then better to
 * simplify the array `P` before checking for the polygon (using the
 * `simplify_polygon` function).  Function `simplify_check_polygon` may be
 * useful for this purpose.
 *
 * The given array is not mutated in the function.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 * @return
 *     Value `true` if `P` is not a null-pointer, the number of points is at
 *     least 3, no three consecutive points are on the same line and no two
 *     line segments that do not share a same end-point intersect; otherwise
 *     value `false`.
 *
 * @see simplify_polygon
 * @see simplify_check_polygon
 *
 */
#if !defined(__cplusplus)
bool check_polygon (size_t n, const real_t* P)
#else
bool check_polygon (::size_t n, const real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Answer. */
    bool answer;

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
#else
    ::size_t i;
    ::size_t j;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    const real_t* x_i0;
    const real_t* y_i0;
    const real_t* x_i1;
    const real_t* y_i1;
    const real_t* x_j0;
    const real_t* y_j0;
    const real_t* x_j1;
    const real_t* y_j1;

    /* Differences in coordinates. */
    real_t dx_i;
    real_t dy_i;
    real_t dx_j;
    real_t dy_j;

    /* Signs of expressions of lines evaluated at certain points. */
    sign_t s_i0;
    sign_t s_i1;
    sign_t s_j0;
    sign_t s_j1;

    /* INITIALISATION OF VARIABLES */

    /* Answer. */
    answer = false;

    /* Iteration indices. */
    i = 0U;
    j = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_i0 = (real_t*)(NULL);
    y_i0 = (real_t*)(NULL);
    x_i1 = (real_t*)(NULL);
    y_i1 = (real_t*)(NULL);
    x_j0 = (real_t*)(NULL);
    y_j0 = (real_t*)(NULL);
    x_j1 = (real_t*)(NULL);
    y_j1 = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_i0 = reinterpret_cast<real_t*>(NULL);
    y_i0 = reinterpret_cast<real_t*>(NULL);
    x_i1 = reinterpret_cast<real_t*>(NULL);
    y_i1 = reinterpret_cast<real_t*>(NULL);
    x_j0 = reinterpret_cast<real_t*>(NULL);
    y_j0 = reinterpret_cast<real_t*>(NULL);
    x_j1 = reinterpret_cast<real_t*>(NULL);
    y_j1 = reinterpret_cast<real_t*>(NULL);
#else
    x_i0 = nullptr;
    y_i0 = nullptr;
    x_i1 = nullptr;
    y_i1 = nullptr;
    x_j0 = nullptr;
    y_j0 = nullptr;
    x_j1 = nullptr;
    y_j1 = nullptr;
#endif /* __cplusplus */

    /* Differences in coordinates. */
    dx_i = 0.0;
    dy_i = 0.0;
    dx_j = 0.0;
    dy_j = 0.0;

    /* Signs of expressions of lines evaluated at certain points. */
#if !defined(__cplusplus) || (__cplusplus) < 201103L
    s_i0 = zero;
    s_i1 = zero;
    s_j0 = zero;
    s_j1 = zero;
#else
    s_i0 = sign_t::zero;
    s_i1 = sign_t::zero;
    s_j0 = sign_t::zero;
    s_j1 = sign_t::zero;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* Initialise the answer to `true` (assume the points define a true
     * polygon). */
    answer = true;

    /* If the pointer `P` is a null-pointer, set the number `n` to 0 and set the
     * answer to `false`. */
    if (!P)
    {
        /* Set the number `n` to 0. */
        n = 0U;

        /* Set the answer to `false`. */
        answer = false;
    }

    /* If the number of points is strictly less than 3, set the answer to
     * `false`. */
    if (n < 3U)
        answer = false;

    /* Iterate over the points.  If the answer becomes `false`, immediately
     * break the `for`-loop. */
    for (i = 0U; answer && i < n; ++i)
    {
        /* Extract the coordinates of the `i`-th point---point P_i0. */
        x_i0 = P + (i << 1U);
        y_i0 = x_i0 + 1U;

        /* Extract the coordinates of the ((`i` + 1) mod n)-th point---point
         * P_i1. */
        x_i1 = P + (incmod(i, n) << 1U);
        y_i1 = x_i1 + 1U;

        /* If the points P_i0 and P_i1 are coordinately the same, set the answer
         * to `false` and break the `for`-loop. */
        if (*x_i1 == *x_i0 && *y_i1 == *y_i0)
        {
            /* Set the answer to `false`. */
            answer = false;

            /* Break the `for`-loop. */
            break;
        }

        /* Compute the index `j` of the point directly preceeding the point
         * P_i0. */
        j = decmod(i, n);

        /* Extract the coordinates of the `j`-th point. */
        x_j1 = P + (j << 1U);
        y_j1 = x_j1 + 1U;

        /* If the point P_i0 is on the line through the `j`-th point and the
         * point P_i1, set the answer to `false` and break the `for`-loop. */
        if (
            (*x_i1 - *x_j1) * (*y_i0 - *y_j1) ==
                (*y_i1 - *y_j1) * (*x_i0 - *x_j1)
        )
        {
            /* Set the answer to `false`. */
            answer = false;

            /* Break the `for`-loop. */
            break;
        }

        /* Compute the differences in coordinates of points P_i0 and P_i1. */
        dx_i = *x_i1 - *x_i0;
        dy_i = *y_i1 - *y_i0;

        /* Iterate over the points after the point P_i1 and check if the edge
         * P_i0 P_i1 intersect with any successive edge. */
        for (j = i + 2U; j < n; ++j)
        {
            /* Extract the coordinates of the `j`-th point---point P_j0. */
            x_j0 = P + (j << 1U);
            y_j0 = x_j0 + 1U;

            /* Extract the coordinates of the ((`j` + 1) mod n)-th point---
             * point P_j1. */
            x_j1 = P + (incmod(j, n) << 1U);
            y_j1 = x_j1 + 1U;

            /* If the point P_j0 is in fact point P_i1 or the point P_j1 is in
             * fact point Pi0, break the `for`-loop. */
            if (
                (x_j0 == x_i1 && y_j0 == y_i1) || (x_j1 == x_i0 && y_j1 == y_i0)
            )
                break;

            /* Compute the differences in coordinates of points P_j0 and
             * P_j1. */
            dx_j = *x_j1 - *x_j0;
            dy_j = *y_j1 - *y_j0;

            /* Compute the signs of expressions of the line P_j0 P_j1 evaluated
             * at points P_i0 and P_i1, and of the line P_i0 P_i1 evaluated at
             * points P_j0 and P_j1. */
            s_i0 = rsign(dx_j * (*y_i0 - *y_j0) - dy_j * (*x_i0 - *x_j0));
            s_i1 = rsign(dx_j * (*y_i1 - *y_j0) - dy_j * (*x_i1 - *x_j0));
            s_j0 = rsign(dx_i * (*y_j0 - *y_i0) - dy_i * (*x_j0 - *x_i0));
            s_j1 = rsign(dx_i * (*y_j1 - *y_i0) - dy_i * (*x_j1 - *x_i0));

            /* If all four points are on the same line, continue to the next
             * iteration (next points P_j0 and P_j1). */
#if !defined(__cplusplus)
            if (!((int)s_i0 && (int)s_i1 && (int)s_j0 && (int)s_j1))
#else
            if (
                !(
                    static_cast<int>(s_i0) &&
                    static_cast<int>(s_i1) &&
                    static_cast<int>(s_j0) &&
                    static_cast<int>(s_j1)
                )
            )
#endif /* __cplusplus */
                continue;

            /* If the points P_i0 and P_i1 are on the opposite sides of the line
             * P_j0 P_j1 (allowing them to be on the line as well), and the
             * points P_j0 and P_j1 are on the opposite sides of the line P_i0
             * P_i1 (again, allowing the points to be on the line), the line
             * segments P_i0 P_i1 and P_j0 P_j1 are crossing.  If that is the
             * case, set the answer to `false` and break the `for`-loop. */
#if !defined(__cplusplus)
            if (
                !(
                    (int)s_i0 * (int)s_i1 == 1 ||
                    (int)s_j0 * (int)s_j1 == 1
                )
            )
#else
            if (
                !(
                    static_cast<int>(s_i0) * static_cast<int>(s_i1) == 1 ||
                    static_cast<int>(s_j0) * static_cast<int>(s_j1) == 1
                )
            )
#endif /* __cplusplus */
            {
                /* Set the answer to `false`. */
                answer = false;

                /* Break the `for`-loop. */
                break;
            }
        }
    }

    /* Return the answer. */
    return answer;
}

/**
 * Simplify and check if an array of points is an ordered set of true vertices
 * of a polygon.
 *
 * The function is a wrapper around the functions `simplify_polygon` and
 * `check_polygon`.
 *
 * The given array is mutated in the `simplify_polygon` function.
 *
 * @param n
 *     Pointer to the variable defining the (maximal) number of points.  The
 *     number `*n` is updated after the simplification (if the number is
 *     reduced, the value of the variable pointed at by `n` is set to the new
 *     number of points).
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function `simplify_polygon`.
 *
 * @return
 *     If `n` is not a null-pointer, the value returned by the function
 *     `check_polygon` after the simplification done by the function
 *     `simplify_polygon`; otherwise value `false`.
 *
 * @see simplify_polygon
 * @see check_polygon
 *
 */
#if !defined(__cplusplus)
bool simplify_check_polygon (size_t* n, real_t* P)
#else
bool simplify_check_polygon (::size_t* n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Answer. */
    bool answer;

    /* INITIALISATION OF VARIABLES */

    /* Answer. */
    answer = false;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If `n` is a null-pointer, break the `do while`-loop. */
        if (!n)
            break;

        /* If the pointer `P` is a null-pointer, set the number `*n` to 0. */
        if (!P)
            *n = 0U;

        /* Simplify the array and update the number `*n`. */
#if !defined(__cplusplus)
        *n = (size_t)(simplify_polygon(*n, P) - P) >> 1U;
#else
        *n = static_cast<size_t>(simplify_polygon(*n, P) - P) >> 1U;
#endif /* __cplusplus */

        /* Check for the polygon and update the answer. */
        answer = check_polygon(*n, P);
    }
    while (false);

    /* Return the answer. */
    return answer;
}

/**
 * Compute the diameter of a finite set of points.
 *
 * The given array is not mutated in the function.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.
 *
 * @param sq
 *     If `false`, the true diameter is returned;  otherwise the squared
 *     diameter is returned.  To get the squared diameter, it is more efficient
 *     to pass a non-false value as `sq` than to square the result after calling
 *     the function with `sq` set to `false` as non-squared diameter is computed
 *     from the squared diameter merely using the function `rsqrt`.
 *
 * @return
 *     Maximal Euclidean distance between the points (squared if
 *     `sq` != `false`).
 *
 * @see rsqrt
 *
 */
#if !defined(__cplusplus)
real_t diameter_polygon (size_t n, const real_t* P, bool sq)
#else
real_t diameter_polygon (::size_t n, const real_t* P, bool sq)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
#else
    ::size_t i;
    ::size_t j;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    const real_t* x_0;
    const real_t* y_0;
    const real_t* x_1;
    const real_t* y_1;

    /* Differences in coordinates. */
    real_t dx;
    real_t dy;

    /* Maximal found distance and an arbitrary distance (most probably
     * squared). */
    real_t D;
    real_t d;

    /* INITIALISATION OF VARIABLES */

    /* Iteration indices. */
    i = 0U;
    j = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_0 = (real_t*)(NULL);
    y_0 = (real_t*)(NULL);
    x_1 = (real_t*)(NULL);
    y_1 = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_0 = reinterpret_cast<real_t*>(NULL);
    y_0 = reinterpret_cast<real_t*>(NULL);
    x_1 = reinterpret_cast<real_t*>(NULL);
    y_1 = reinterpret_cast<real_t*>(NULL);
#else
    x_0 = nullptr;
    y_0 = nullptr;
    x_1 = nullptr;
    y_1 = nullptr;
#endif /* __cplusplus */

    /* Differences in coordinates. */
    dx = 0.0;
    dy = 0.0;

    /* Maximal found Euclidean distance and an arbitrary Euclidean distance
     * (most probably squared). */
    D = 0.0;
    d = 0.0;

    /* ALGORITHM */

    /* If the pointer `P` is a null-pointer, set the number `n` to 0. */
    if (!P)
        n = 0U;

    /* Iterate over the points. */
    for (i = 0U; i < n; ++i)
    {
        /* Extract the coordinates of the `i`-th point. */
        x_0 = P + (i << 1U);
        y_0 = x_0 + 1U;

        /* Iterate over the remaining points and check the distances from the
         * `i`-th point. */
        for (j = i + 1U; j < n; ++j)
        {
            /* Extract the coordinates of the `j`-th point. */
            x_1 = P + (j << 1U);
            y_1 = x_1 + 1U;

            /* Compute the differences in coordinates of the `i`-th and the
             * `j`-th points. */
            dx = *x_1 - *x_0;
            dy = *y_1 - *y_0;

            /* Compute the sqared Euclidean distance between the `i`-th and the
             * `j`-th points. */
            d = dx * dx + dy * dy;

            /* If the current distance is larger than the distance `D`, set the
             * distance `D` to the value of the current distance `d`. */
            if (d > D)
                D = d;
        }
    }

    /* Return the diameter of the set; squared or not according to value of the
     * parameter `sq`. */
    return sq ? D : rsqrt(D);
}

/**
 * Reflex a set of points over axes.
 *
 * Reflexion over the x-axis changes the signs of the x-coordinates of the
 * vertices and reflexion over the y-axis changes the signs of the y-coordinates
 * of the vertices.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.  The order of points
 *     is preserved (the `i`-th point after the transformation is the point into
 *     which the original `i`-th point was transformed).
 *
 * @param x
 *     Whether or not the reflexion over the x-axis should be done.
 *
 * @param y
 *     Whether or not the reflexion over the y-axis should be done.
 *
 */
#if !defined(__cplusplus)
void reflex_polygon (size_t n, real_t* P, bool x, bool y)
#else
void reflex_polygon (::size_t n, real_t* P, bool x, bool y)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* Auxiliary pointer to coordinate of a point. */
    real_t* aux;

    /* INITIALISATION OF VARIABLES */

    /* Iteration index. */
    i = 0U;

    /* Auxiliary pointer to coordinate of a point. */
#if !defined(__cplusplus)
    aux = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    aux = reinterpret_cast<real_t*>(NULL);
#else
    aux = nullptr;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* If the pointer `P` is a null-pointer, set the number `n` to 0. */
    if (!P)
        n = 0U;

    /* If the reflexion over the x-axis is to be done, change signs of the
     * x-coordinates of the vertices. */
    if (x)
        /* Iterate over the points and transform them. */
        for (i = 0U; i < n; ++i)
        {
            /* Extract the x-coordinate of the `i`-th point. */
            aux = P + (i << 1U);

            /* Reflex the x-coordinate of the `i`-th point. */
            *aux = (*aux == 0.0) ? 0.0 : -*aux;
        }

    /* If the reflexion over the y-axis is to be done, change signs of the
     * y-coordinates of the vertices. */
    if (y)
        /* Iterate over the points and transform them. */
        for (i = 0U; i < n; ++i)
        {
            /* Extract the y-coordinate of the `i`-th point. */
            aux = P + (i << 1U) + 1U;

            /* Reflex the y-coordinate of the `i`-th point. */
            *aux = (*aux == 0.0) ? 0.0 : -*aux;
        }
}

/**
 * Rotate a set of points around the origin by a rectangular rotation.
 *
 * Use this function instead of the function `rotate_polygon` if the rotation
 * angle is a multiple of pi / 2 because no sines or cosines are computed in
 * this function.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.  The order of points
 *     is preserved (the `i`-th point after the transformation is the point into
 *     which the original `i`-th point was transformed).
 *
 * @param k
 *     Multiplier of pi / 2 for the rotation angle.  The points are rotated by
 *     `k` * pi / 2.
 *
 * @see rotate_polygon
 *
 */
#if !defined(__cplusplus)
void rect_rotate_polygon (size_t n, real_t* P, int k)
#else
void rect_rotate_polygon (::size_t n, real_t* P, int k)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x;
    real_t* y;

    /* Auxiliary value. */
    real_t aux;

    /* INITIALISATION OF VARIABLES */

    /* Iteration index. */
    i = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x = (real_t*)(NULL);
    y = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x = reinterpret_cast<real_t*>(NULL);
    y = reinterpret_cast<real_t*>(NULL);
#else
    x = nullptr;
    y = nullptr;
#endif /* __cplusplus */

    /* Auxiliary value. */
    aux = 0.0;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If the pointer `P` is a null-pointer, set the number `n` to 0 and
         * break the `do while`-loop. */
        if (!P)
        {
            /* Set the numbre `n` to 0. */
            n = 0U;

            /* Break the `do while`-loop. */
            break;
        }

        /* If the number of points is less than 2, break the `do while`-loop. */
        if (!n)
            break;

        /* Compute `k` mod 4 and do the right transformation according to the
         * result. */
        switch (k % 4)
        {
            /* If `k` mod 4 == 0, no transformation needs to be done. */
            case  0:
                break;

            /* If `k` mod 4 == 1, set x-coordinates to y-coordinates but with
             * changed signs and set y-coordinates to x-coordinates. */
            case  1:
            case -3:
                /* Iterate over the points and transform them. */
                for (i = 0U; i < n; ++i)
                {
                    /* Extract coordinates of the `i`-th point. */
                    x = P + (i << 1U);
                    y = x + 1U;

                    /* Transform coordinates of the `i`-th point using the
                     * auxiliary value. */
                    aux = *x;
                    *x = (*y == 0.0) ? 0.0 : -*y;
                    *y = aux;
                }

                /* Break the `switch`. */
                break;

            /* If `k` mod 4 == 2, change signs of coordinates. */
            case  2:
            case -2:
                /* Iterate over the points and transform them. */
                for (i = 0U; i < n; ++i)
                {
                    /* Extract coordinates of the `i`-th point. */
                    x = P + (i << 1U);
                    y = x + 1U;

                    /* Transform coordinates of the `i`-th point. */
                    *x = (*x == 0.0) ? 0.0 : -*x;
                    *y = (*y == 0.0) ? 0.0 : -*y;
                }

                /* Break the `switch`. */
                break;

            /* If `k` mod 4 == 3, set x-coordinates to y-coordinates and set
             * y-coordinates to x-coordinates but with changed signs. */
            case  3:
            case -1:
                /* Iterate over the points and transform them. */
                for (i = 0U; i < n; ++i)
                {
                    /* Extract coordinates of the `i`-th point. */
                    x = P + (i << 1U);
                    y = x + 1U;

                    /* Transform coordinates of the `i`-th point using the
                     * auxiliary value. */
                    aux = *x;
                    *x = *y;
                    *y = (*x == 0.0) ? 0.0 : -*x;
                }

                /* Break the `switch`. */
                break;

            /* By default, do nothing (all cases were actually explicitly
             * caught---default case will never be reached). */
            default:
                break;
        }
    }
    while (false);
}

/**
 * Rotate a set of points around the origin.
 *
 * If the angle is a multiple of pi / 2, use the function `rect_rotate_polygon`
 * instead to avoid computing sines and cosines.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.  The order of points
 *     is preserved (the `i`-th point after the transformation is the point into
 *     which the original `i`-th point was transformed).
 *
 * @param phi
 *     Angle of rotation.
 *
 * @see rect_rotate_polygon
 *
 */
#if !defined(__cplusplus)
void rotate_polygon (size_t n, real_t* P, real_t phi)
#else
void rotate_polygon (::size_t n, real_t* P, real_t phi)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Sine and cosine of the angle of rotation. */
    real_t sin_phi;
    real_t cos_phi;

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x;
    real_t* y;

    /* Auxiliary value. */
    real_t aux;

    /* INITIALISATION OF VARIABLES */

    /* Sine and cosine of the angle of rotation. */
    sin_phi = 0.0;
    cos_phi = 0.0;

    /* Iteration index. */
    i = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x = (real_t*)(NULL);
    y = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x = reinterpret_cast<real_t*>(NULL);
    y = reinterpret_cast<real_t*>(NULL);
#else
    x = nullptr;
    y = nullptr;
#endif /* __cplusplus */

    /* Auxiliary value. */
    aux = 0.0;

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If the pointer `P` is a null-pointer, set the number `n` to 0 and
         * break the `do while`-loop. */
        if (!P)
        {
            /* Set the numbre `n` to 0. */
            n = 0U;

            /* Break the `do while`-loop. */
            break;
        }

        /* If the number of points is less than 2, break the `do while`-loop. */
        if (!n)
            break;

        /* Compute the sine and the cosine of the angle of rotation. */
        sin_phi = rsin(phi);
        cos_phi = rcos(phi);

        /* Iterate over the points and rotate them. */
        for (i = 0U; i < n; ++i)
        {
            /* Extract coordinates of the `i`-th point. */
            x = P + (i << 1U);
            y = x + 1U;

            /* Rotate coordinates of the `i`-th point using the auxiliary
             * value. */
            aux = *x;
            *x = cos_phi * aux - sin_phi * *y;
            *y = sin_phi * aux + cos_phi * *y;
        }
    }
    while (false);
}

/**
 * Translate an array of points so that all the coordinates stretch inside a
 * Certesian product of two symmetric closed intervals.
 *
 * All the x-coordinates of the points are decremented by
 * (`x_min` + `x_max`) / 2, and all the y-coordinates are decremented by
 * (`y_min` + `y_max`) / 2, where `x_min`, `x_max`, `y_min` and `y_max` are the
 * smallest and the largest x-coordinates and the smallest and the largest
 * y-coordinates respectively.
 *
 * The function mutates the given array.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 */
#if !defined(__cplusplus)
void centralise_polygon (size_t n, real_t* P)
#else
void centralise_polygon (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Extreme and middle coordinates of points. */
    real_t x_min;
    real_t y_min;
    real_t x_mid;
    real_t y_mid;
    real_t x_max;
    real_t y_max;

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    real_t* x_i;
    real_t* y_i;

    /* INITIALISATION OF VARIABLES */

    /* Extreme and middle coordinates of points. */
    x_min = 0.0;
    y_min = 0.0;
    x_mid = 0.0;
    y_mid = 0.0;
    x_max = 0.0;
    y_max = 0.0;

    /* Iteration index. */
    i = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_i = (real_t*)(NULL);
    y_i = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_i = reinterpret_cast<real_t*>(NULL);
    y_i = reinterpret_cast<real_t*>(NULL);
#else
    x_i = nullptr;
    y_i = nullptr;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If the pointer `P` is a null-pointer, set the number `n` to 0 and
         * break the `do while`-loop. */
        if (!P)
        {
            /* Set the numbre `n` to 0. */
            n = 0U;

            /* Break the `do while`-loop. */
            break;
        }

        /* If the number of points is 0, break the `do while`-loop. */
        if (!n)
            break;

        /* Initialise the extreme coordinates to the coordinates of the first
         * point. */
        x_min = *P;
        y_min = *(P + 1U);
        x_max = x_min;
        y_max = y_min;

        /* Iterate over the rest of the points to find the most extreme
         * coordinates. */
        for (i = 1U; i < n; ++i)
        {
            /* Extract the coordinates of the `i`-th point. */
            x_i = P + (i << 1U);
            y_i = x_i + 1U;

            /* If either of the `i`-th point's coordinates is more extreme than
             * the most extreme coordinates so far, update the extreme
             * coordinates accordingly. */
            if (*x_i < x_min)
                x_min = *x_i;
            if (x_max < *x_i)
                x_max = *x_i;
            if (*y_i < y_min)
                y_min = *y_i;
            if (y_max < *y_i)
                y_max = *y_i;
        }

        /* Compute the middle coordinates. */
        x_mid = x_min + 0.5 * (x_max - x_min);
        y_mid = y_min + 0.5 * (y_max - y_min);

        /* Iterate over the points and translate their coordinates. */
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) -= (i & 1U) ? y_mid : x_mid;
    }
    while (false);
}

/**
 * Standardise an array of points by dividing all the coordinates by the
 * diameter of the set of the points.
 *
 * If the diameter `d` of the set of the points is not 0, all the coordinates
 * are divided by `d`; otherwise all the coordinates are set to (0, 0).
 *
 * The function mutates the given array.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.
 *
 *     Caution: the array `P` is mutated in the function.
 *
 */
#if !defined(__cplusplus)
void standardise_polygon (size_t n, real_t* P)
#else
void standardise_polygon (::size_t n, real_t* P)
#endif /* __cplusplus */
{
    /* INITIALISATION OF VARIABLES */

    /* Diameter. */
    real_t d;

    /* Iteration index. */
#if !defined(__cplusplus)
    size_t i;
#else
    ::size_t i;
#endif /* __cplusplus */

    /* INITIALISATION OF VARIABLES */

    /* Diameter. */
    d = 0.0;

    /* Iteration index. */
    i = 0U;

    /* ALGORITHM */

    /* If the pointer `P` is a null-pointer, set the number `n` to 0. */
    if (!P)
        n = 0U;

    /* Compute the diameter of the set of the points. */
    d = diameter_polygon(n, P, false);

    /* Update the points' coordinates. */

    /* If the diameter is 0, iterate over the points and set their coordinates
     * to (0, 0). */
    if (d == 0.0)
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) = 0.0;
    /* Otherwise iterate over the points and divide their coordinates by `d`. */
    else
        for (i = 0U; (i >> 1U) < n; ++i)
            *(P + i) /= d;
}

/**
 * Describe a polygon defined by an array of its vertices by computing the
 * lengths of its edges and outer angles.
 *
 * The lengths of the edges of the polygon are computed using the `rsqrt`
 * function and the outer angles are computed using the `racos` function.  The
 * outer angles' values are from the interval (-pi, pi].
 *
 * The memory for the arrays of the edges' lengths and the outer angles must be
 * preallocated.  If either of the arguments passed is a null-pointer, no effect
 * will be made.  If the memory locations of either of the five arrays overlap,
 * the results will be unexpected.
 *
 * The results may also be unexpected if the array of points is not an array of
 * coordinates of true vertices of a polygon in the mathematically positive
 * order.  To assure this, simplify the polygon, check it if it really is a
 * polygon and reorder the vertices using the `simplify_polygon`,
 * `check_polygon` (or `simplify_check_polygon`) and
 * `correct_polygon_orientation` functions.
 *
 * The array `P` is not mutated in the function, but the arrays `l` and `phi`
 * are.
 *
 * @param n
 *     Number of points.
 *
 * @param P
 *     Array of points of size at least 2 * `n`.  The array is organised as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th point and `y_i` is its y-coordinate.  Note
 *     that the first and the last points are neighbouring.  The points
 *     represent the vertices of the polygon.
 *
 * @param dx
 *     Array of the differences in x-coordinates of points.  The array is filled
 *     as
 *     {x_1 - x_0, x_2 - x_1, ..., x_n_minus_1 - x_n_minus_2,
 *     x_0 - x_n_minus_1}.
 *
 * @param dy
 *     Array of the differences in y-coordinates of points.  The array is filled
 *     as
 *     {y_1 - y_0, y_2 - y_1, ..., y_n_minus_1 - y_n_minus_2,
 *     y_0 - y_n_minus_1}.
 *
 * @param l
 *     Array of the edges' lengths of size at least `n`.  The array is filled as
 *     {|(x_0, y_0), (x_1, y_1)|, |(x_1, y_1), (x_2, y_2)|, ...,
 *     |(x_n_minus_2, y_n_minus_2), (x_n_minus_1, y_n_minus_1)|,
 *     |(x_n_minus_1, y_n_minus_1), (x_0, y_0)|}, where |(x_A, y_A), (x_B, y_B)|
 *     is the distance from the point A = (x_A, y_A) to the point
 *     B = (x_B, y_B).
 *
 *     Caution: the array is mutated in the function.
 *
 * @param phi
 *     Array of the outer angles of size at least `n`.  The array is filled as
 *     `{phi_1, phi_2, ..., phi_n_minus_2, phi_n_minus_1, phi_0}`, where `phi_i`
 *     is the outer angle at the `i`-th vertex.
 *
 *     Caution: the array is mutated in the function.
 *
 * @see simplify_polygon
 * @see check_polygon
 * @see simplify_check_polygon
 * @see correct_polygon_orientation
 *
 */
#if !defined(__cplusplus)
void describe_polygon (
    size_t n,
    const real_t* P,
    real_t* dx,
    real_t* dy,
    real_t* l,
    real_t* phi
)
#else
void describe_polygon (
    ::size_t n,
    const real_t* P,
    real_t* dx,
    real_t* dy,
    real_t* l,
    real_t* phi
)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Iteration indices. */
#if !defined(__cplusplus)
    size_t i;
    size_t j;
    size_t k;
#else
    ::size_t i;
    ::size_t j;
    ::size_t k;
#endif /* __cplusplus */

    /* Auxiliary pointers to coordinates of points. */
    const real_t* x_i;
    const real_t* y_i;
    const real_t* x_j;
    const real_t* y_j;
    const real_t* x_k;
    const real_t* y_k;

    /* Auxiliary pointers to differences in coordinates. */
    real_t* dx_i;
    real_t* dy_i;
    real_t* dx_j;
    real_t* dy_j;

    /* Auxiliary pointers to lengths of edges. */
    real_t* l_i;
    real_t* l_j;

    /* Auxiliary pointer to outer edge. */
    real_t* phi_i;

    /* INITIALISATION OF VARIABLES */

    /* Iteration indices. */
    i = 0U;
    j = 0U;
    k = 0U;

    /* Auxiliary pointers to coordinates of points. */
#if !defined(__cplusplus)
    x_i = (real_t*)(NULL);
    y_i = (real_t*)(NULL);
    x_j = (real_t*)(NULL);
    y_j = (real_t*)(NULL);
    x_k = (real_t*)(NULL);
    y_k = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    x_i = reinterpret_cast<real_t*>(NULL);
    y_i = reinterpret_cast<real_t*>(NULL);
    x_j = reinterpret_cast<real_t*>(NULL);
    y_j = reinterpret_cast<real_t*>(NULL);
    x_k = reinterpret_cast<real_t*>(NULL);
    y_k = reinterpret_cast<real_t*>(NULL);
#else
    x_i = nullptr;
    y_i = nullptr;
    x_j = nullptr;
    y_j = nullptr;
    x_k = nullptr;
    y_k = nullptr;
#endif /* __cplusplus */

    /* Auxiliary pointers to differences in coordinates. */
#if !defined(__cplusplus)
    dx_i = (real_t*)(NULL);
    dy_i = (real_t*)(NULL);
    dx_j = (real_t*)(NULL);
    dy_j = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    dx_i = reinterpret_cast<real_t*>(NULL);
    dy_i = reinterpret_cast<real_t*>(NULL);
    dx_j = reinterpret_cast<real_t*>(NULL);
    dy_j = reinterpret_cast<real_t*>(NULL);
#else
    dx_i = nullptr;
    dy_i = nullptr;
    dx_j = nullptr;
    dy_j = nullptr;
#endif /* __cplusplus */

    /* Auxiliary pointers to lengths of edges. */
#if !defined(__cplusplus)
    l_i = (real_t*)(NULL);
    l_j = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    l_i = reinterpret_cast<real_t*>(NULL);
    l_j = reinterpret_cast<real_t*>(NULL);
#else
    l_i = nullptr;
    l_j = nullptr;
#endif /* __cplusplus */

    /* Auxiliary pointer to outer edge. */
#if !defined(__cplusplus)
    phi_i = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    phi_i = reinterpret_cast<real_t*>(NULL);
#else
    phi_i = nullptr;
#endif /* __cplusplus */

    /* ALGORITHM */

    /* If either of the pointers `P`, `dx`, `dy`, `l` and `phi` is a
     * null-pointer, set the number `n` to 0. */
    if (!(P && dx && dy && l && phi))
        n = 0U;

    /* Initialise the arrays `dx`, `dy`, `l` and `phi` to zeros. */
#if !defined(__cplusplus)
    memset(dx, 0, n * sizeof *dx);
    memset(dy, 0, n * sizeof *dy);
    memset(l, 0, n * sizeof *l);
    memset(phi, 0, n * sizeof *phi);
#else
    ::memset(dx, 0, n * sizeof *dx);
    ::memset(dy, 0, n * sizeof *dy);
    ::memset(l, 0, n * sizeof *l);
    ::memset(phi, 0, n * sizeof *phi);
#endif /* __cplusplus */

    /* Iterate over the points and compute the lengths of edges and the outer
     * angles. */
    for (i = 0U; i < n; ++i)
    {
        /* Compute the indices of the next two points. */
        j = incmod(i, n);
        k = incmod(j, n);

        /* Ektract the coordinates of the `i`-th, the `j`-th and the `k`-th
         * points---points `P_i`, `P_j` and `P_k` respectively. */
        x_i = P + (i << 1U);
        y_i = x_i + 1U;
        x_j = P + (j << 1U);
        y_j = x_j + 1U;
        x_k = P + (k << 1U);
        y_k = x_k + 1U;

        /* Extract the differences in lengths of coordinates from points P_i and
         * P_j. */
        dx_i = dx + i;
        dy_i = dy + i;
        dx_j = dx + j;
        dy_j = dy + j;

        /* Compute the differences in coordinates of points P_i and P_j, and
         * points P_j and P_k. */
        if (*dx_i == 0.0)
            *dx_i = *x_j - *x_i;
        if (*dy_i == 0.0)
            *dy_i = *y_j - *y_i;
        if (*dx_j == 0.0)
            *dx_j = *x_k - *x_j;
        if (*dy_j == 0.0)
            *dy_j = *y_k - *y_j;

        /* Extract the lengths of edges P_i P_j and P_j P_k. */
        l_i = l + i;
        l_j = l + j;

        /* If the lengths of edge P_i P_j is currently set to 0, compute it; do
         * the same with the edge P_j P_k if its length is set to 0. */
        if (*l_i == 0.0)
            *l_i = rsqrt(*dx_i * *dx_i + *dy_i * *dy_i);
        if (*l_j == 0.0)
            *l_j = rsqrt(*dx_j * *dx_j + *dy_j * *dy_j);

        /* Extract the outer angle at the `i`-th point. */
        phi_i = phi + i;

        /* Compute the angle at the point P_j and save its value on the `i`-th
         * place in the array `phi`. */
        *phi_i = racos((*dx_i * *dx_j + *dy_i * *dy_j) / (*l_i * *l_j));
#if !defined(__cplusplus) || (__cplusplus) < 201103L
        if (rsign(*dx_i * (*y_k - *y_i) - (*x_k - *x_i) * *dy_i) == minus)
#else
        if (
            rsign(*dx_i * (*y_k - *y_i) - (*x_k - *x_i) * *dy_i) ==
            sign_t::minus
        )
#endif /* __cplusplus */
            *phi_i = -*phi_i;
    }
}

/**
 * Compute the singular values of the lengths or the outer edges of a polygon.
 *
 * Consider a polygon of n angles.  Choose a vertex and positive or negative
 * orientation.  Denote the polygons vertices starting from the chosen vertex in
 * the chosen orientation V_0, V_1, ..., V_n_minus_one.  Construct a vector
 * (l_0, l_1, ..., l_n_minus_one) such that l_i is the length of the edge
 * V_i V_i_plus_one and a vector (phi_0, phi_1, ..., phi_n_minus_1) such thah
 * phi_i is the outer angle of the polygon at the vertex V_i.  Construct the
 * matrices L, Phi of the unoriented circular representations of the vectors
 * (arrays)---see the `build_unorient_circ_matrix` function.  The singular
 * values of the lengths of edges of the polygon are singular values of the
 * constructed matrix L and the singular values of the outer angles of the
 * polygon are singular values of the constructed matrix Phi.
 *
 * Since the algorithm is the same, a single function is used to calculate both
 * singular values vectors.  Moreover, the function can be used for any array of
 * real values, it does not have to be an array of the lengths of edges or the
 * outer angles of a polygon.
 *
 * If the memory locations of either of the three arrays overlap, the results
 * will be unexpected.
 *
 * The array `a` is not mutated in the function, but the array `A` is.
 *
 * Caution: the function may fail if memory must be allocated for the resulting
 * array, but the allocation failed.  If that happens, the null-pointer is
 * returned.  Exceptions thrown by failed memory allocation in C++ are not
 * caught.
 *
 * @param n
 *     Number of vertices (length of the array `a`).
 *
 * @param a
 *     Array of the lengths of edges or the outer angles (arbitrary array of
 *     finite values none of which is NaN).
 *
 * @param s
 *     Pointer to the first singular value in the array of size at least `n`.
 *
 *     If a null-pointer is passed, the memory is dynamically allocated using
 *     the `malloc` function in C and by calling the `new[]` operator in C++.
 *
 *     Caution: the array is mutated in the function.
 *
 * @param A
 *     Pointer to the first element of the constructed matrix in the array of
 *     size needed for the matrix using the `build_unorient_circ_matrix`
 *     function for an array of size `n`.
 *
 *     If a null-pointer is passed, the memory is dynamically allocated using
 *     the `malloc` function in C and by calling the `new[]` operator in C++ and
 *     deallocated adequately before the function returns.
 *
 *     Caution: the array is mutated in the function.
 *
 * @param info
 *     Pointer to the variable for storing the information from the SVD driver.
 *     A null-pointer is an illegal argument, but this is checked before
 *     the driver is called (segmentation fault will not occur).
 *
 * @return
 *     If `a` and `info` are not null-pointers, array of the singular values;
 *     otherwise the given argument `s`.
 *
 * @see DGESVD
 * @see DGESDD
 * @see build_unorient_circ_matrix
 *
 */
#if !defined(__cplusplus)
real_t* svd_polygon (size_t n, const real_t* a, real_t* s, real_t* A, int* info)
#else
real_t* svd_polygon (
    ::size_t n,
    const real_t* a,
    real_t* s,
    real_t* A,
    int* info
)
#endif /* __cplusplus */
{
    /* DECLARATION OF VARIABLES */

    /* Dimension variable. */
    size_t n2;

    /* Leading dimension variable. */
#if !defined(__cplusplus)
    size_t ld_A;
#else
    ::size_t ld_A;
#endif /* __cplusplus */

    /* Flag for checking if the given pointer `A` is a null-pointer. */
    bool A_null;

    /* Auxiliary dimension variables (of type `int`). */
    int int_n;
    int int_n2;

    /* Auxiliary leading dimension variable (of type `int`). */
    int int_ld_A;

    /* Job string for SVD drivers. */
    char job[2U];

    /* Dimension of the workspace for SVD drivers. */
    int lwork;

    /* Workspace for SVD drivers. */
    real_t* work;

#if (_USE_SVD_DRIVER) == (_DGESDD_DRIVER)
    /* Integer workspace for DGESDD driver. */
    int* iwork;
#endif /* _USE_SVD_DRIVER */

    /* Dummy integer for SVD drivers. */
    int dummy;

    /* INITIALISATION OF VARIABLES */

    /* Dimension variable. */
    n2 = 0U;

    /* Leading dimension variable. */
    ld_A = 0U;

    /* Flag for checking if the given pointer `A` is a null-pointer. */
    A_null = false;

    /* Auxiliary dimension variables (of type `int`). */
    int_n = 0;
    int_n2 = 0;

    /* Auxiliary leading dimension variable (of type `int`). */
    int_ld_A = 0;

    /* Dimension of the workspace for SVD drivers. */
    lwork = 0;

    /* Workspace for SVD drivers. */
#if !defined(__cplusplus)
    work = (real_t*)(NULL);
#elif (__cplusplus) < 201103L
    work = reinterpret_cast<real_t*>(NULL);
#else
    work = nullptr;
#endif /* __cplusplus */

#if (_USE_SVD_DRIVER) == (_DGESDD_DRIVER)
    /* Integer workspace for DGESDD driver. */
#if !defined(__cplusplus)
    iwork = (int*)(NULL);
#elif (__cplusplus) < 201103L
    iwork = reinterpret_cast<int*>(NULL);
#else
    iwork = nullptr;
#endif /* __cplusplus */
#endif /* _USE_SVD_DRIVER */

    /* Dummy integer for SVD drivers. */
    dummy = 0;

    /* ALGORITHM */

    /* Fill the job string for SVD drivers with null-characters. */
#if !defined(__cplusplus)
    memset(job, 0, 2U * sizeof *job);
#else
    ::memset(job, 0, 2U * sizeof *job);
#endif /* __cplusplus */

    /* If the given pointer `A` is a null-pointer, set the flag for checking it
     * to `true`. */
    if (!A)
        A_null = true;

    /* To avoid using the `goto` command and additional `return` commands, the
     * algorithm is enclosed in a `do while`-loop with a false terminating
     * statement. */
    do
    {
        /* If at least one of the pointers `a` and `info` is a null-pointer, set
         * the number `n` to 0 and break the `do while`-loop. */
        if (!(a && info))
        {
            /* Set the numbre `n` to 0. */
            n = 0U;

            /* Break the `do while`-loop. */
            break;
        }

        /* If the number of values is 0, break the `do while`-loop. */
        if (!n)
            break;

        /* Initialise information from SVD drivers to zero. */
        *info = 0;

        /* Set the first character of the job string to `'N'` making it the
         * string `"N"`. */
        *job = 'N';

        /* Allocate the memory for the array `P` if necessary. */
        if (!s)
#if !defined(__cplusplus)
            s = (real_t*)malloc(n * sizeof *s);
#else
            s = new real_t[n];
#endif /* __cplusplus */

        /* If the memory allocation has failed, break the `do while`-loop. */
        if (!s)
            break;

        /* Initialise the array of singular values to zeros. */
#if !defined(__cplusplus)
        memset(s, 0, n * sizeof *s);
#else
        ::memset(s, 0, n * sizeof *s);
#endif /* __cplusplus */

        /* Build the matrix of the unoriented circular representation of the
         * array `a` on `A`. */
#if !defined(__cplusplus)
        A = (real_t*)(
            build_unorient_circ_matrix(A, &n2, &n, &ld_A, a, n, sizeof *a)
        );
#else
        A = reinterpret_cast<real_t*>(
            build_unorient_circ_matrix(A, &n2, &n, &ld_A, a, n, sizeof *a)
        );
#endif /* __cplusplus */

        /* If the pointer `A` is a null-pointer, break the `do while`-loop. */
        if (!A)
            break;

        /* Extract the auxiliary dimension variables. */
        int_n = (int)n;
        int_n2 = (int)n2;

        /* Extract the auxiliary leading dimension variable. */
        int_ld_A = (int)ld_A;

        /* Set the dummy integer of for the SVD drivers to the maximum of
         * 64 * ceil(`n` / 32) and the leading dimension of the matrix `A`. */
        dummy = (n2 < ld_A) ? int_ld_A : (int)(((n2 + 63U) >> 6U) << 6U);

        /* Compute the singular values using the right driver. */


/* Using the DGESVD driver. */
#if (_USE_SVD_DRIVER) == (_DGESVD_DRIVER)

        /* Allocate memory for the initial workspace (for the query). */
#if !defined(__cplusplus)
        work = (real_t*)malloc(sizeof *work);
#else
        work = new real_t[1U];
#endif /* __cplusplus */

        /* If the memory allocation has failed, clear the memory if necessary
         * and break the `do while`-loop. */
        if (!work)
        {
            /* If the given pointer `A` was a null-pointer, clear the memory in
             * the array `A`. */
            if (A_null)
#if !defined(__cplusplus)
                memset(A, 0, n2 * ld_A * sizeof *A);
#else
                ::memset(A, 0, n2 * ld_A * sizeof *A);
#endif /* __cplusplus */

            /* Break the `do while`-loop. */
            break;
        }

        /* Initialise the initial workspace to zeros. */
#if !defined(__cplusplus)
        memset(work, 0, sizeof *work);
#else
        ::memset(work, 0, sizeof *work);
#endif /* __cplusplus */

        /* Set the dimension of the workspace to -1 to query the optimal
         * dimension. */
        lwork = -1;

        /* Query the optimal dimension of the workspace. */
#if !defined(__cplusplus)
        dgesvd_(
            job,
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            (real_t*)(NULL),
            &dummy,
            (real_t*)(NULL),
            &dummy,
            work,
            &lwork,
            info
        );
#elif (__cplusplus) < 201103L
        dgesvd_(
            job,
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            work,
            &lwork,
            info
        );
#else
        dgesvd_(
            job,
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            nullptr,
            &dummy,
            nullptr,
            &dummy,
            work,
            &lwork,
            info
        );
#endif /* __cplusplus */

        /* If the query succeeded, extract the optimal dimension of the
         * workspace. */
        if (!*info)
            lwork = (int)(*work);

        /* Clear the memory in the initial workspace. */
#if !defined(__cplusplus)
        memset(work, 0, sizeof *work);
#else
        ::memset(work, 0, sizeof *work);
#endif /* __cplusplus */

        /* Free the memory allocated for the initial workspace. */
#if !defined(__cplusplus)
        free(work);
        work = (real_t*)(NULL);
#else
        delete[] work;
#if (__cplusplus) < 201103L
        work = reinterpret_cast<real_t*>(NULL);
#else
        work = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

        /* If the query has not suceeded, clear the memory if necessary and
         * break the `do while`-loop. */
        if (*info)
        {
            /* If the given pointer `A` was a null-pointer, clear the memory in
             * the array `A`. */
            if (A_null)
#if !defined(__cplusplus)
                memset(A, 0, n2 * ld_A * sizeof *A);
#else
                ::memset(A, 0, n2 * ld_A * sizeof *A);
#endif /* __cplusplus */

            /* Break the `do while`-loop. */
            break;
        }

        /* Allocate memory for the workspace. */
#if !defined(__cplusplus)
        work = (real_t*)malloc((size_t)lwork * sizeof *work);
#else
        work = new real_t[(size_t)lwork];
#endif /* __cplusplus */

        /* If the memory allocation has failed, clear the memory if necessary
         * and break the `do while`-loop. */
        if (!work)
        {
            /* If the given pointer `A` was a null-pointer, clear the memory in
             * the array `A`. */
            if (A_null)
#if !defined(__cplusplus)
                memset(A, 0, n2 * ld_A * sizeof *A);
#else
                ::memset(A, 0, n2 * ld_A * sizeof *A);
#endif /* __cplusplus */

            /* Break the `do while`-loop. */
            break;
        }

        /* Initialise the workspace to zeros. */
#if !defined(__cplusplus)
        memset(work, 0, (size_t)lwork * sizeof *work);
#else
        ::memset(work, 0, (size_t)lwork * sizeof *work);
#endif /* __cplusplus */

        /* Compute the singular values. */
#if !defined(__cplusplus)
        dgesvd_(
            job,
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            (real_t*)(NULL),
            &dummy,
            (real_t*)(NULL),
            &dummy,
            work,
            &lwork,
            info
        );
#elif (__cplusplus) < 201103L
        dgesvd_(
            job,
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            work,
            &lwork,
            info
        );
#else
        dgesvd_(
            job,
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            nullptr,
            &dummy,
            nullptr,
            &dummy,
            work,
            &lwork,
            info
        );
#endif /* __cplusplus */

        /* Clear the memory in the workspace. */
#if !defined(__cplusplus)
        memset(work, 0, (size_t)lwork * sizeof *work);
#else
        ::memset(work, 0, (size_t)lwork * sizeof *work);
#endif /* __cplusplus */

        /* Free the memory allocated for the workspace. */
#if !defined(__cplusplus)
        free(work);
        work = (real_t*)(NULL);
#else
        delete[] work;
#if (__cplusplus) < 201103L
        work = reinterpret_cast<real_t*>(NULL);
#else
        work = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

/* Using the DGESDD driver. */
#elif (_USE_SVD_DRIVER) == (_DGESDD_DRIVER)

        /* Allocate memory for the initial workspace (for the query). */
#if !defined(__cplusplus)
        work = (real_t*)malloc(sizeof *work);
        iwork = (int*)malloc((n << 3U) * sizeof *work);
#else
        work = new real_t[1U];
        iwork = new int[n << 3U];
#endif /* __cplusplus */

        /* If the memory allocation has failed, clear the memory if necessary
         * and break the `do while`-loop. */
        if (!(work && iwork))
        {
            /* Deallocate memory. */
#if !defined(__cplusplus)
            free(work);
            free(iwork);
            work = (real_t*)(NULL);
            iwork = (int*)(NULL);
#else
            delete[] work;
            delete[] iwork;
#if (__cplusplus) < 201103L
            work = reinterpret_cast<real_t*>(NULL);
            iwork = reinterpret_cast<int*>(NULL);
#else
            work = nullptr;
            iwork = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

            /* If the given pointer `A` was a null-pointer, clear the memory in
             * the array `A`. */
            if (A_null)
#if !defined(__cplusplus)
                memset(A, 0, n2 * ld_A * sizeof *A);
#else
                ::memset(A, 0, n2 * ld_A * sizeof *A);
#endif /* __cplusplus */

            /* Break the `do while`-loop. */
            break;
        }

        /* Initialise the initial workspace to zeros. */
#if !defined(__cplusplus)
        memset(work, 0, sizeof *work);
        memset(iwork, 0, (n << 3U) * sizeof *iwork);
#else
        ::memset(work, 0, sizeof *work);
        ::memset(iwork, 0, (n << 3U) * sizeof *iwork);
#endif /* __cplusplus */

        /* Set the dimension of the workspace to -1 to query the optimal
         * dimension. */
        lwork = -1;

        /* Query the optimal dimension of the workspace. */
#if !defined(__cplusplus)
        dgesdd_(
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            (real_t*)(NULL),
            &dummy,
            (real_t*)(NULL),
            &dummy,
            work,
            &lwork,
            iwork,
            info
        );
#elif (__cplusplus) < 201103L
        dgesdd_(
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            work,
            &lwork,
            iwork,
            info
        );
#else
        dgesdd_(
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            nullptr,
            &dummy,
            nullptr,
            &dummy,
            work,
            &lwork,
            iwork,
            info
        );
#endif /* __cplusplus */

        /* If the query succeeded, extract the optimal dimension of the
         * workspace. */
        if (!*info)
            lwork = (int)(*work);

        /* Clear the memory in the initial workspace. */
#if !defined(__cplusplus)
        memset(work, 0, sizeof *work);
        memset(iwork, 0, (n << 3U) * sizeof *iwork);
#else
        ::memset(work, 0, sizeof *work);
        ::memset(iwork, 0, (n << 3U) * sizeof *iwork);
#endif /* __cplusplus */

        /* Free the memory allocated for the initial workspace. */
#if !defined(__cplusplus)
        free(work);
        work = (real_t*)(NULL);
#else
        delete[] work;
#if (__cplusplus) < 201103L
        work = reinterpret_cast<real_t*>(NULL);
#else
        work = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

        /* If the query has not suceeded, clear the memory if necessary and
         * break the `do while`-loop. */
        if (*info)
        {
            /* Free the memory allocated for the integer workspace. */
#if !defined(__cplusplus)
            free(iwork);
            iwork = (int*)(NULL);
#else
            delete[] iwork;
#if (__cplusplus) < 201103L
            iwork = reinterpret_cast<int*>(NULL);
#else
            iwork = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

            /* If the given pointer `A` was a null-pointer, clear the memory in
             * the array `A`. */
            if (A_null)
#if !defined(__cplusplus)
                memset(A, 0, n2 * ld_A * sizeof *A);
#else
                ::memset(A, 0, n2 * ld_A * sizeof *A);
#endif /* __cplusplus */

            /* Break the `do while`-loop. */
            break;
        }

        /* Allocate memory for the workspace. */
#if !defined(__cplusplus)
        work = (real_t*)malloc((size_t)lwork * sizeof *work);
#else
        work = new real_t[(size_t)lwork];
#endif /* __cplusplus */

        /* If the memory allocation has failed, clear the memory if necessary
         * and break the `do while`-loop. */
        if (!work)
        {
            /* Free the memory allocated for the integer workspace. */
#if !defined(__cplusplus)
            free(iwork);
            iwork = (int*)(NULL);
#else
            delete[] iwork;
#if (__cplusplus) < 201103L
            iwork = reinterpret_cast<int*>(NULL);
#else
            iwork = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

            /* If the given pointer `A` was a null-pointer, clear the memory in
             * the array `A`. */
            if (A_null)
#if !defined(__cplusplus)
                memset(A, 0, n2 * ld_A * sizeof *A);
#else
                ::memset(A, 0, n2 * ld_A * sizeof *A);
#endif /* __cplusplus */

            /* Break the `do while`-loop. */
            break;
        }

        /* Initialise the workspace to zeros. */
        memset(work, 0, (size_t)lwork * sizeof *work);

        /* Compute the singular values. */
#if !defined(__cplusplus)
        dgesdd_(
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            (real_t*)(NULL),
            &dummy,
            (real_t*)(NULL),
            &dummy,
            work,
            &lwork,
            iwork,
            info
        );
#elif (__cplusplus) < 201103L
        dgesdd_(
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            reinterpret_cast<real_t*>(NULL),
            &dummy,
            work,
            &lwork,
            iwork,
            info
        );
#else
        dgesdd_(
            job,
            &int_n,
            &int_n2,
            A,
            &int_ld_A,
            s,
            nullptr,
            &dummy,
            nullptr,
            &dummy,
            work,
            &lwork,
            iwork,
            info
        );
#endif /* __cplusplus */

        /* Clear the memory in the workspace. */
#if !defined(__cplusplus)
        memset(work, 0, sizeof *work);
        memset(iwork, 0, (n << 3U) * sizeof *iwork);
#else
        ::memset(work, 0, sizeof *work);
        ::memset(iwork, 0, (n << 3U) * sizeof *iwork);
#endif /* __cplusplus */

        /* Free the memory allocated for the workspace. */
#if !defined(__cplusplus)
        free(work);
        free(iwork);
        work = (real_t*)(NULL);
        iwork = (int*)(NULL);
#else
        delete[] work;
        delete[] iwork;
#if (__cplusplus) < 201103L
        work = reinterpret_cast<real_t*>(NULL);
        iwork = reinterpret_cast<int*>(NULL);
#else
        work = nullptr;
        iwork = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */

#endif /* _USE_SVD_DRIVER */

        /* If the given pointer `A` was a null-pointer, clear the memory in the
         * array `A`. */
        if (A_null)
#if !defined(__cplusplus)
            memset(A, 0, n2 * ld_A * sizeof *A);
#else
            ::memset(A, 0, n2 * ld_A * sizeof *A);
#endif /* __cplusplus */
    }
    while (false);

    /* If the given pointer `A` was a null-pointer, free the memroy allocated
     * for the array `A`. */
    if (A_null)
    {
#if !defined(__cplusplus)
        free(A);
        work = (real_t*)(NULL);
#else
        delete[] A;
#if (__cplusplus) < 201103L
        A = reinterpret_cast<real_t*>(NULL);
#else
        A = nullptr;
#endif /* __cplusplus */
#endif /* __cplusplus */
    }

    /* Return the array of the singular values. */
    return s;
}

/**
 * Dump polygons to an output.
 *
 * Each set of `n` points is dumped as
 *     x_0	y_0	x_1	y_2	...	x_n_minus_1	y_n_minus_1
 * where the coordinates are delimited by a tabulator and each coordinate is
 * printed to a fixed precision.  Each set of points is printed in its own line,
 * however, the first set of points is directly printed to the output without
 * printing a new line character beforehand.  To ensure that the first set of
 * points is printed in its own line, give an empty output as the argument `out`
 * or print a new line character and flush the output before calling the
 * function.  Sets of points are printed in the given order.
 *
 * @param out
 *     Output location.  In C, coordinates are printed using the `fprintf`
 *     function from the standard library.  In C++, coordinates are printed
 *     using the adequate `::std::ostream::operator<<`.
 *
 *     Before dumping it is checked if the argument is legal (is not a
 *     null-pointer in C or does not return `true` on `out.fail()` in C++).  If
 *     illegal, no output is printed to avoid errors.
 *
 *     In C++, the fixed precision remains set on the output after the function.
 *
 * @param n
 *     Number of points in each set.
 *
 * @param P
 *     Array of points of size at least `N` * 2 * `n`.  Each segment of length
 *     2 * `n` of the array (from indices 2 * i including to 2 * (i + 1)
 *     excluding for an index 0 <= i < N) represents a polygon and is organised
 *     as
 *     `{x_0, y_0, x_1, y_1, ..., x_n_minus_1, y_n_minus_1}`, where `x_i` is the
 *     x-coordinate of the `i`-th vertex of the polygon and `y_i` is its
 *     y-coordinate.  Note that the first and the last points inside a segment
 *     are neighbouring.
 *
 * @param N
 *     Number of polygons.
 *
 */
#if !defined(__cplusplus)
void dump_polygons (FILE* out, size_t n, const real_t* P, size_t N)
#else
void dump_polygons (
    ::std::ostream& out,
    ::size_t n,
    const real_t* P,
    ::size_t N
)
#endif /* __cplusplus */
{
    /* DECLARATION OF STATIC VARIABLES */

    /* Precision of the output. */
#if !defined(__cplusplus)
    static const size_t prec = 8U;
#else
    static const ::size_t prec = 8U;
#endif /* __cplusplus */

    /* Delimiter of coordinates inside a set of points. */
#if !defined(__cplusplus)
    static const char* const delim = "\t";
#else
    static const ::std::string delim("\t");
#endif /* __cplusplus */

#if !defined(__cplusplus)
    /* Formats for the fisrt coordinate inside a set of points and the rest. */
    static const char* const format_first = "%.*f";
    static const char* const format_rest = "%s%.*f";
#endif /* __cplusplus */

#if !defined(__cplusplus)
    /* New line string. */
    static const char* const new_line = "\n";
#endif /* __cplusplus */

    /* DECLARATION OF VARIABLES */

    /* Iteration indices. */
    size_t i;
    size_t j;

    /* INITIALISATION OF VARIABLES */

    /* Iteration indices. */
    i = 0U;
    j = 0U;

    /* ALGORITHM */

    /* If the output is invalid, if the pointer `P` is a null-pointer or if any
     * of the numbers `n` and `N` is 0, set the numbers `n` and `N` to 0. */
#if ( \
    !defined(__cplusplus) || \
    (defined(__cplusplus) && !((__cplusplus) < 201103L)) \
)
    if (!(out && n && P && N))
#else
    if (out.fail() || !(n && P && N))
#endif /* __cplusplus */
    {
        n = 0U;
        N = 0U;
    }

#if defined(__cplusplus)
    /* Set the output format to fixed and set the precision of the output. */
#if (__cplusplus) < 201103L
    if (!out.fail())
#else
    if (out)
#endif /* __cplusplus */
    {
        out << ::std::fixed;
        out << ::std::setprecision(static_cast<int>(prec));
    }
#endif /* __cplusplus */

    /* Iterate over the sets of points and dump them. */
    for (i = 0U; i < N; ++i)
    {
        /* Dump the x-coordinate of the fisrt point. */
#if !defined(__cplusplus)
        fprintf(out, format_first, (int)prec, *(P + ((i * n) << 1U)));
#else
        out << *(P + ((i * n) << 1U));
#endif /* __cplusplus */

        /* Iterate over the rest of the coordinates and dump them. */
        for (j = 1U; (j >> 1U) < n; ++j)
#if !defined(__cplusplus)
            fprintf(
                out,
                format_rest,
                    delim,
                    (int)prec,
                    *(P + ((i * n) << 1U) + j)
            );
#else
            out << delim << *(P + ((i * n) << 1U) + j);
#endif /* __cplusplus */

        /* Print a new line. */
#if !defined(__cplusplus)
        fprintf(out, new_line);
#else
        out << ::std::endl;
#endif /* __cplusplus */
    }
}

#endif /* __POLYGON_H__INCLUDED */

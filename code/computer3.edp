/****************************************************************************/
/* FreeFEM script for computing Laplace eigenvalues on polygons.            */
/*                                                                          */
/* This file is part of Davor Penzar's master thesis programing.            */
/*                                                                          */
/* Usage:                                                                   */
/*     $ FreeFem++ computer3.edp [-i file_in] [-o file_out]                 */
/* Arguments:                                                               */
/*     -i: <filename>  path to the input file (default: "in.tsv")           */
/*     -o: <filename>  path to the output file (default: "out.tsv")         */
/* Other arguments are ignored.                                             */
/*                                                                          */
/* Consider an open nonempty set $ \Omega \subseteq \mathbb{R}^{2} $ such   */
/* that its boundary $ \partial \Omega $ is piecewise smooth.  A value      */
/* $ \lambda \in \mathbb{R}^{2} $ is called the EIGENVALUE OF THE LAPLACE   */
/* OPERATOR (ON $ \Omega $) if there exists a continuous nonconstant        */
/* function $ u \colon \overline{\Omega} \to \mathbb{R}^{2} $ twice         */
/* differential on $ \Omega $ such that                                     */
/*     $ \Delta u = \lambda u $ on $ \Omega $,                              */
/*     $ u = 0 $ on $ \partial \Omega $,                                    */
/* where $ \Delta $ denotes the Laplace operator (sum of all second partial */
/* derivatives)---the function $ u $ is then called the EIGENFUNCTION OF    */
/* THE LAPLACE OPERATOR (ON $ \Omega $).  If $ \Omega $ is bounded, these   */
/* eigenvalues and eigenfunctions exist, for each eigenvalue there are      */
/* finitely many lineary independent eigenfunctions, and there are          */
/* countably infinitely many eigenvalues all of which are strictly positive */
/* with no accumulation point.                                              */
/*                                                                          */
/* The script reads definitions of polygons and prints the numerical        */
/* approximations of the first eigenvalues of the Laplace operator on the   */
/* polygons.                                                                */
/*                                                                          */
/* The number of polygons read from the input file is hard coded in the     */
/* script.  To change it, update the global parameter `np`.                 */
/*                                                                          */
/* Each polygon must be formated in the input file as                       */
/*     x0 y0 x1 y1 ... xn yn                                                */
/* where:                                                                   */
/*     n + 1   is the number of vertices,                                   */
/*     xi      is the x-coordinate of the i-th vertex,                      */
/*     yi      is the y-coordinate of the i-th vertex.                      */
/* Whitespaces may differ (they may even be spaces, tabs, line breaks...).  */
/* All of the polygons must have the same number of vertices; moreover, the */
/* number is hard coded in the script.  To change the number of vertices,   */
/* update the global parameter `nv`, the definition of the border, the      */
/* plotting of the border and the definition of the mesh.                   */
/*                                                                          */
/* Eigenvalues are printed to the output file in the same order as the      */
/* polygons are defined in the input file, each in its own line.  An extra  */
/* new line (empty) is added at the end of the output file.  The precision  */
/* of the output is hard coded in the script (global parameter `prec`).     */
/*                                                                          */
/* The whole input file is read before any computation and the information  */
/* is stored in global arrays (consuming RAM).  Also, the first eigenvalues */
/* are stored in a global array and no first eigenvalue is printed before   */
/* the computation ends on all polygons.  The reason for this is to get a   */
/* a better sense of time needed to compute the eigenvalues.  If there is   */
/* not enough RAM to store all the information needed for a large number of */
/* polygons, split the input file in multiple smaller files and run the     */
/* script on each of the smaller inputs.                                    */
/*                                                                          */
/* The current number of vertices is 3 (hence the name of the script        */
/* "computer3.edp").                                                        */
/*                                                                          */
/* The code is inspired by the example of the solution of the Laplace       */
/* eigenvalue problem given at                                              */
/* https://doc.freefem.org/models/eigen-value-problems.html                 */
/****************************************************************************/

// Include the getARGV header.
include "getARGV.idp"

// Define the global parameters.
verbosity = 0;      // Verbosity level 0.
int prec = 8;       // Precision of the output.
real tol = 1.0e-12; // Tolerance for the solution.
real eps = 1.0e-24; // Epsilon for the CG solver.
int np = 3;         // Number of polygons.
int nv = 3;         // Number of vertices (change code acccordingly).
int unit = 20;      // Number of mesh points on an edge of length 1.
int nev = 1;        // Number of eigenvalues to compute.

// Declare input/output arrays.
real[int, int] Px(np, nv);  // x-coordinates of vertices.
real[int, int] Py(np, nv);  // y-coordinates of vertices.
real[int] ev0(np);          // The first eigenvalues.

// Declare variables to store time.
real t0 = 0.0;
real t1 = 0.0;

// Read the input.
{
    // Open the input file.
    ifstream in(getARGV("-i", "in.tsv"));

    // Get time in seconds.
    t0 = clock();

    // Read from the input file.
    for (int i = 0; i < np; ++i)
        for (int j = 0; j < nv; ++j)
            in >> Px(i, j) >> Py(i, j);

    // Get time in seconds.
    t1 = clock();

    // Print elapsed time.
    cout << "Reading: " << (t1 - t0) << "s." << endl;
}

// Get time in seconds.
t0 = clock();

// Compute the eigenvalues.
for (int i = 0; i < np; ++i)
{
    // Declare auxiliary arrays for border parameters.
    real[int] lx(nv);   // Differences in x-coordinates of vertices.
    real[int] ly(nv);   // Differences in y-coordinates of vertices.
    int[int] nm(nv);    // Numbers of mesh points on edges.

    // Compute border parameters.
    for (int j = 0; j < nv; ++j)
    {
        lx(j) = Px(i, (j + 1) % nv) - Px(i, j);
        ly(j) = Py(i, (j + 1) % nv) - Py(i, j);
        nm(j) = max(round(unit * dist(lx(j), ly(j))), 2.0);
    }

    // Define the border.
    border Gamma0 (t = 0.0, 1.0)
    {
        x = Px(i, 0) + lx(0) * t;
        y = Py(i, 0) + ly(0) * t;
        label = i;
    }
    border Gamma1 (t = 0.0, 1.0)
    {
        x = Px(i, 1) + lx(1) * t;
        y = Py(i, 1) + ly(1) * t;
        label = i;
    }
    border Gamma2 (t = 0.0, 1.0)
    {
        x = Px(i, 2) + lx(2) * t;
        y = Py(i, 2) + ly(2) * t;
        label = i;
    }

//  // Plot the border.
//  plot(
//      Gamma0(nm(0)) +
//      Gamma1(nm(1)) +
//      Gamma2(nm(2)),
//      cmm = "Polygon " + i + ": Border",
//      wait = true
//  );

    // Build the mesh.
    mesh Th = buildmesh(
        Gamma0(nm(0)) +
        Gamma1(nm(1)) +
        Gamma2(nm(2))
    );

//  // Plot the mesh.
//  plot(
//      Th,
//      cmm = "Polygon " + i + ": Mesh",
//      wait = true
//  );

    // Build the finite element space.
    fespace Vh(Th, P2); // P2 conforming triangular finite element space.
    Vh u1;
    Vh u2;

    // Define the problem.
    varf a (u1, u2) =
        int2d(Th)(dx(u1) * dx(u2) + dy(u1) * dy(u2)) +
        on(i, u1 = 0);                      // With boundary condition.
    varf b (u1, u2) = int2d(Th)(u1 * u2);   // No boundary condition.

    // Construct the matrices for the problem.
    matrix A = a(Vh, Vh, solver = Crout, factorize = 1);
    matrix B = b(Vh, Vh, solver = CG, eps = eps);

    // Construct the arrays for the solution.
    real[int] ev(nev);  // To store the `nev` eigenvalues.
    Vh[int] eV(nev);    // To store the `nev` eigenvectors (eigenfunctions).

    // Solve the problem.
    int k = EigenValue(
        A,
        B,
        nev = nev,
        sym = true,
        value = ev,
        vector = eV,
        tol = tol,
        sigma = 0.0,
        maxit = 0,
        ncv = 0
    );

//  // Display and plot the solution.  The eigenvalues and the eigenvectors
//  // (eigenfunctions) are indexed starting from 0.
//  cout << "Polygon " << i << ":" << endl;
//  for (int j = 0; j < k; ++j)
//  {
//      // Extract the eigenvector
//      u1 = eV[j];
//
//      // Display the eigenvalue.
//      cout <<
//          "\tlambda[" << j << "] = " << ev[j] <<
//          ", " <<
//          "err = " <<
//              abs(
//                  int2d(Th)(
//                      dx(u1) * dx(u1) +
//                      dy(u1) * dy(u1) -
//                      ev[j] * u1 * u1
//                  )
//              ) <<
//          endl;
//
//      // Plot the eigenvector (eigenfunction).
//      plot(
//          eV[j],
//          cmm =
//              "Polygon " + i + ":" +
//              " " +
//              "eigenvector " + j +
//              ", " +
//              "eigenvalue = " + ev[j],
//          value = true,
//          wait = true
//      );
//  }

    // Save the first eigenvalue.
    ev0[i] = k ? ev[0] : 0.0;
}

// Get time in seconds.
t1 = clock();

// Print elapsed time.
cout << "Computing: " << (t1 - t0) << "s." << endl;

// Print the output.
{
    // Open the output file.
    ofstream out(getARGV("-o", "out.tsv"));

    // Set the precision of the output.
    out.fixed;
    out.precision(prec);

    // Get time in seconds.
    t0 = clock();

    // Print to the output file.
    for (int i = 0; i < np; ++i)
        out << ev0[i] << endl;

    // Get time in seconds.
    t1 = clock();

    // Print elapsed time.
    cout << "Printing: " << (t1 - t0) << "s." << endl;
}

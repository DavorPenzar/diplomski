<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>script API documentation</title>
<meta name="description" content="Useful functions â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>script</code></h1>
</header>
<section id="section-intro">
<p>Useful functions.</p>
<h2 id="dependencies">Dependencies</h2>
<ol>
<li>Standard Python library:<ol>
<li><code>copy</code>,</li>
<li><code>math</code>,</li>
<li><code>numbers</code>,</li>
<li><code>six</code>,</li>
<li><code>warnings</code>,</li>
</ol>
</li>
<li>SciPy library:<ol>
<li><code>matplotlib</code><ol>
<li><code>matplotlib.axes</code>,</li>
<li><code>matplotlib.pyplot</code>,</li>
</ol>
</li>
<li><code>mpl_toolkits.mplot3d</code>,</li>
<li><code>numpy</code><ol>
<li><code>numpy.linalg</code>,</li>
</ol>
</li>
<li><code>scipy.sparse</code><ol>
<li><code>scipy.sparse.linalg</code>.</li>
</ol>
</li>
</ol>
</li>
</ol>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
Useful functions.

Dependencies
------------
1.  Standard Python library:
    1.  `copy`,
    2.  `math`,
    3.  `numbers`,
    4.  `six`,
    5.  `warnings`,
2.  SciPy library:
    1.  `matplotlib`
        1.  `matplotlib.axes`,
        2.  `matplotlib.pyplot`,
    2.  `mpl_toolkits.mplot3d`,
    3.  `numpy`
        1.  `numpy.linalg`,
    4.  `scipy.sparse`
        1.  `scipy.sparse.linalg`.

&#34;&#34;&#34;

# Standard Python library.
import copy as _copy
import math as _math
import numbers as _numbers
import six as _six
import warnings as _warnings

# SciPy packages.
import matplotlib as _mpl
import matplotlib.pyplot as _plt
import numpy as _np
import scipy.sparse as _sp
from matplotlib.axes import Axes as _Axes
from mpl_toolkits.mplot3d import Axes3D as _Axes3D
from numpy.linalg import eig as _eig
from scipy.sparse.linalg import eigs as _eigs

def triang (x = 1, y = None, num = 50, return_dom = False):
    &#34;&#34;&#34;
    Compute the discretisation of a rectangle containing an open triangle.

    Parameters
    ----------
    x : real in range [0, +inf) or (3,) array_like of reals, optional
        Width or x-values of the vertices of the triangle (default is 1).  If a
        single floating point value is passed, it defines the width of the
        triangle.  If an array of three values is passed, each value defines the
        x-value of a vertix of the triangle.  Passing a single value `x` is the
        same as passing `[-x / 2, x / 2, 0]`.  If a single value is passed as
        the parameter `x` and `None` is passed as `y`, the value of `x` does not
        affect the resulting rectangle (probably except for extremely large or
        extremely small values, and definitely except for zero versus non-zero
        values), therefore the parameter `x` is optional.

    y : None or real in range [0, +inf) or (3,) array_like of reals, optional
        Height or y-values of the vertices of the triangle (default is `None`).
        If a single floating point value is passed, it defines the height of the
        triangle.  If an array of three values is passed, each value defines the
        y-value of a vertix of the triangle.  Passing a single value `y` is the
        same as passing `[-y / 2, -y / 2, y / 2]`.  If `None`,
        `sqrt(0.75) * abs(x[1] - x[0])` is used as the height of the triangle.

    num : int in range [2, +inf), optional
        The number of discretisation points used to discretise the wider
        dimension of the resulting rectangle (default is 50).

    return_dom : boolean, optional
        If `True`, the rectangle&#39;s boundaries are returned as well as the
        rectangle itself (default is `False`).

    Returns
    -------
    Omega : (M, N) array of booleans
        Array of trues and falses representing the discretisation of the
        rectangle containing the closure of the triangle.  The rectangle will
        span from `min(x)` to `max(x)` on its first dimension, and from `min(y)`
        to `max(y)` on its second dimension, and the equality `max(M, N) == num`
        will be true.  If the ratio
        (`max(x)` - `min(x)`) / (`max(y)` - `min(y)`) (allowing for the
        denominator to be equal to 0) cannot be written as a rational number
        p / q such that max(p, q) = `num`, then the narrower dimension of the
        rectangle is stretched, possibly resulting in a few additional
        rows/columns filled with falses --- this is done so that the
        discretisation step is equal on both the x-axis and the y-axis.  The
        values of Omega are defined as: `Omega[i, j] == True` if and only if the
        point at the intersection of the `i`-th discretisation line of the
        x-axis and the `j`-th discretisation line of the y-axis is inside the
        open triangle.  Note that the first dimension represents the x-axis.

    dom : (2, 2) array of floats
        The rectangle that is returned spans from `dom[0, 0]` to `dom[0, 1]` on
        the x-axis, and from `dom[1, 0]` to `dom[1, 1]` on the y-axis.  It is
        guarranteed that `(dom[:, 0] &lt;= dom[:, 1]).all()` is `True`.  This is
        returned only if the parameter `return_dom` is `True`.

    Raises
    ------
    TypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.

    &#34;&#34;&#34;

    # Define comparison objects used for ordering &lt;, &gt;, &lt;= and &gt;=.
    LT_check = lambda r, s : r &lt; s
    GT_check = lambda r, s : r &gt; s
    LE_check = lambda r, s : r &lt;= s
    GE_check = lambda r, s : r &gt;= s

    # Sanitise the parameter x.
    if isinstance(x, _np.ndarray):
        if x.size == 1:
            x = x.ravel()
            x = x.dtype.type(x[0])
    if hasattr(x, &#39;__iter__&#39;) or hasattr(x, &#39;__array__&#39;):
        if not isinstance(x, _np.ndarray):
            try:
                x = _np.array(x)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;x must be a scalar or an array.&#39;)
        if not issubclass(x.dtype.type, _numbers.Real):
            raise TypeError(&#39;x must be real.&#39;)
        x = x.astype(float)
        if not x.ndim == 1:
            raise ValueError(&#39;x must be a 1-dimensional array.&#39;)
        if not x.size == 3:
            raise ValueError(&#39;x must have exactly 3 elements.&#39;)
    else:
        if not isinstance(x, _numbers.Real):
            raise TypeError(&#39;Width must be real.&#39;)
        try:
            x = _copy.deepcopy(float(x))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;Width must be of type float.&#39;)
        if _math.isnan(x) or _math.isinf(x):
            raise ValueError(&#39;Width must not be NaN or infinite.&#39;)
        if x &lt; 0.0:
            raise ValueError(&#39;Width must not be negative&#39;)
        x = 0.5 * _np.array([-x, x, 0.0], dtype = float, order = &#39;F&#39;)
    if _np.isnan(x).any() or _np.isinf(x).any():
        raise ValueError(&#39;x must be non-NaN and finite.&#39;)
    x[~x.astype(bool)] = 0

    # If y is None, define the heigt of the triangle.
    if y is None:
        y = _math.sqrt(0.75) * abs(float(x[1] - x[0]))

    # Sanitise the parameter y.
    if isinstance(y, _np.ndarray):
        if y.size == 1:
            y = y.ravel()
            y = y.dtype.type(y[0])
    if hasattr(y, &#39;__iter__&#39;) or hasattr(y, &#39;__array__&#39;):
        if not isinstance(y, _np.ndarray):
            try:
                y = _np.array(y)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;y must be a scalar or an array.&#39;)
        if not issubclass(y.dtype.type, _numbers.Real):
            raise TypeError(&#39;y must be real.&#39;)
        y = y.astype(float)
        if not y.ndim == 1:
            raise ValueError(&#39;y must be a 1-dimensional array.&#39;)
        if not y.size == 3:
            raise ValueError(&#39;y must have exactly 3 elements.&#39;)
    else:
        if not isinstance(y, _numbers.Real):
            raise TypeError(&#39;Height must be real.&#39;)
        try:
            y = _copy.deepcopy(float(y))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;Height must be of type float.&#39;)
        if _math.isnan(y) or _math.isinf(y):
            raise ValueError(&#39;Height must not be NaN or infinite.&#39;)
        if y &lt; 0.0:
            raise ValueError(&#39;Height must be positive.&#39;)
        y = 0.5 * _np.array([-y, -y, y], dtype = float, order = &#39;F&#39;)
    if _np.isnan(y).any() or _np.isinf(y).any():
        raise ValueError(&#39;y must be non-NaN and finite.&#39;)
    y[~y.astype(bool)] = 0

    # Sanitise the parameter num.
    if isinstance(num, _np.ndarray):
        if num.size == 1:
            num = num.ravel()
            num = num.dtype.type(num[0])
    if not isinstance(num, _numbers.Integral):
        raise TypeError(&#39;Number of discretisation points must be integral.&#39;)
    try:
        num = _copy.deepcopy(int(num))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Number of discretisation points must be of type int.&#39;)
    if num &lt; 2:
        raise ValueError(
            &#39;Number of discretisation points must be greater than 1.&#39;
        )

    # Sanitise the parameter return_dom.
    if isinstance(return_dom, _np.ndarray):
        if return_dom.size == 1:
            return_dom = return_dom.ravel()
            return_dom = return_dom.dtype.type(return_dom[0])
    if not isinstance(
        return_dom,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Parameter return_dom must be boolean.&#39;)
    try:
        if return_dom not in {0, False, 1, True}:
            raise ValueError(&#39;Parameter return_dom must be False or True.&#39;)
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Parameter return_dom must be False or True.&#39;)
    try:
        return_dom = _copy.deepcopy(bool(return_dom))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(&#39;Parameter return_dom must be of type bool.&#39;)

    # Compute the boundaries and the dimensions of the rectangle.

    x_min = float(x.min())
    x_max = float(x.max())

    y_min = float(y.min())
    y_max = float(y.max())

    a = x_max - x_min
    b = y_max - y_min

    # Initialize the rectangle to all falses.
    Omega = None
    if a &lt; b:
        k = int(_math.ceil(num * a / b))
        a_ = k * b / num
        X = x_min + x_max
        x_min, x_max = ((X - a_) / 2, (X + a_) / 2)
        Omega = _np.zeros((k, num), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del a_
        del X
    elif a &gt; b:
        k = int(_math.ceil(num * b / a))
        b_ = k * a / num
        Y = y_min + y_max
        y_min, y_max = ((Y - b_) / 2, (Y + b_) / 2)
        Omega = _np.zeros((num, k), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del b_
        del Y
    else:
        Omega = _np.zeros((num, num), dtype = _np.uint8, order = &#39;F&#39;)
    if x_min == 0:
        x_min = 0.0
    if x_max == 0:
        x_max = 0.0
    if y_min == 0:
        y_min = 0.0
    if y_max == 0:
        y_max = 0.0

    # Discretise the rectangle.
    u = _np.linspace(x_min, x_max, num = Omega.shape[0])
    v = _np.linspace(y_min, y_max, num = Omega.shape[1])

    ##  The following code is derived from the formula generating the line
    ##  interpolating two different points on a plane.  For the points
    ##  (x_A, y_A) and (x_B, y_B), if x_B != x_A, the line is generated by the
    ##  explicit formula
    ##      y = (y_B - y_A) / (x_B - x_A) * (x - x_A) + y_A.
    ##  If x_B == x_A, then y_B != y_A (otherwise the points would not be
    ##  different) and the formula could be generated to define x for a fixed
    ##  value of y.  Either way, a point is below/to the left from the line if
    ##  the equality is replaced by &lt;, and above/to the right it if the equality
    ##  is replaced by &gt;.  Then, we multiply the inequality by (x_B - x_A) or
    ##  (y_B - y_A) depending on the case and eventualy get
    ##      (x_B - x_A) * (y - y_A) @ (y_B - y_A) * (x - x_A)
    ##  where @ is the corresponding sign among &lt; and &gt; (opposite the original
    ##  if x_B &lt; x_A).  Knowing the coordinates of the points, the sign can be
    ##  inferred simply by checking which of the two is satisfied.

    # Using the objects LT_check and GT_check, define the comparison objects to
    # check if a point is inside the triangle.
    liner_check = [
        LT_check if LE_check(
            (x[1] - x[0]) * (y[2] - y[0]),
            (y[1] - y[0]) * (x[2] - x[0])
        ) else GT_check,
        LT_check if LE_check(
            (x[2] - x[1]) * (y[0] - y[1]),
            (y[2] - y[1]) * (x[0] - x[1])
        ) else GT_check,
        LT_check if LE_check(
            (x[0] - x[2]) * (y[1] - y[2]),
            (y[0] - y[2]) * (x[1] - x[2])
        ) else GT_check
    ]

    # Compute the values to compare to check if the point is inside the
    # triangle.
    u_liner = _np.array(
        [
            (y[1] - y[0]) * (u - x[0]),
            (y[2] - y[1]) * (u - x[1]),
            (y[0] - y[2]) * (u - x[2])
        ],
        dtype = float,
        order = &#39;F&#39;
    )
    v_liner = _np.array(
        [
            (x[1] - x[0]) * (v - y[0]),
            (x[2] - x[1]) * (v - y[1]),
            (x[0] - x[2]) * (v - y[2])
        ],
        dtype = float,
        order = &#39;F&#39;
    )

    # Fill the rectangle with trues where needed.
    I = list(range(int(u.size)))
    J = list(range(int(v.size)))
    for i in I:
        for j in J:
            Omega[i, j] = _np.bool8(
                liner_check[0](v_liner[0, j], u_liner[0, i]) and
                liner_check[1](v_liner[1, j], u_liner[1, i]) and
                liner_check[2](v_liner[2, j], u_liner[2, i])
            )
        try:
            del j
        except (NameError, UnboundLocalError):
            pass
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    del I
    del J

    # Free the memory.
    del u_liner
    del v_liner
    del u
    del v

    # Return the rectangle and, if needed, the domain&#39;s boundaries.
    return (
        (
            Omega,
            _np.array(
                [[x_min, x_max], [y_min, y_max]],
                dtype = float,
                order = &#39;F&#39;
            )
        ) if return_dom else Omega
    )

def ellips (a = 1, b = None, num = 50, return_dom = False):
    &#34;&#34;&#34;
    Compute the discretisation of a rectangle containing an open ellipsis.

    Parameters
    ----------
    a : real in range [0, +inf), optional
        The width of the ellipsis (default is 1).  If a value is passed as the
        parameter `a` and `None` is passed as `b`, the value of `a` does not
        affect the resulting rectangle (probably except for extremely large or
        extremely small values, and definitely except for zero versus non-zero
        values), therefore the parameter `a` is optional.

    b : None or real in range [0, +inf), optional
        The height of the ellipsis (default is `None`).  If `None`, height will
        be equal to width.

    num : int in range [2, +inf), optional
        The number of discretisation points used to discretise the wider
        dimension of the resulting rectangle (default is 50).

    return_dom : boolean, optional
        If `True`, the rectangle&#39;s boundaries are returned as well as the
        rectangle itself (default is `False`).

    Returns
    -------
    Omega : (M, N) array of booleans
        Array of trues and falses representing the discretisation of the
        rectangle containing the closure of the ellipsis.  The rectangle will
        span from `-a` to `a` on its first dimension, and from `-b` to `b` on
        its second dimension, and the equality `max(M, N) == num` will be true.
        If the ratio `a` / `b` (allowing for the denominator to be equal to 0)
        cannot be written as a rational number p / q such that
        max(p, q) = `num`, then the narrower dimension of the rectangle is
        stretched, possibly resulting in a few additional rows/columns filled
        with falses --- this is done so that the discretisation step is equal on
        both the x-axis and the y-axis.  The values of `Omega` are defined as:
        `Omega[i, j] == True` if and only if the point at the intersection of
        the `i`-th discretisation line of the x-axis and the `j`-th
        discretisation line of the y-axis is inside the open ellipsis.  Note
        that the first dimension represents the x-axis.

    dom : (2, 2) array of floats
        The rectangle that is returned spans from `dom[0, 0]` to `dom[0, 1]` on
        the x-axis, and from `dom[1, 0]` to `dom[1, 1]` on the y-axis.  It is
        guarranteed that `(dom[:, 0] &lt;= dom[:, 1]).all()` is `True`.  This is
        returned only if the parameter `return_dom` is `True`.

    Raises
    ------
    TypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.

    &#34;&#34;&#34;

    # Sanitise the parameter a.
    if isinstance(a, _np.ndarray):
        if a.size == 1:
            a = a.ravel()
            a = a.dtype.type(a[0])
    if not isinstance(a, _numbers.Real):
        raise TypeError(&#39;a must be real.&#39;)
    try:
        a = _copy.deepcopy(float(a))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;a must be of type float.&#39;)
    if _math.isnan(a) or _math.isinf(a):
        raise ValueError(&#39;a must be non-NaN and finite.&#39;)
    if a &lt; 0:
        raise ValueError(&#39;a must not be negative.&#39;)
    if a == 0:
        a = 0.0

    # If b is None, define the height of the ellipsis.
    if b is None:
        b = a

    # Sanitise the parameter b.
    if isinstance(b, _np.ndarray):
        if b.size == 1:
            b = b.ravel()
            b = b.dtype.type(b[0])
    if not isinstance(b, _numbers.Real):
        raise TypeError(&#39;b must be real.&#39;)
    try:
        b = _copy.deepcopy(float(b))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;b must be of type float.&#39;)
    if _math.isnan(b) or _math.isinf(b):
        raise ValueError(&#39;b must be non-NaN and finite.&#39;)
    if b &lt; 0:
        raise ValueError(&#39;b must not be negative.&#39;)
    if b == 0:
        b = 0.0

    # Sanitise the parameter num.
    if isinstance(num, _np.ndarray):
        if num.size == 1:
            num = num.ravel()
            num = num.dtype.type(num[0])
    if not isinstance(num, _numbers.Integral):
        raise TypeError(&#39;Number of discretisation points must be integral.&#39;)
    try:
        num = _copy.deepcopy(int(num))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Number of discretisation points must be of type int.&#39;)
    if num &lt; 2:
        raise ValueError(
            &#39;Number of discretisation points must be greater than 1.&#39;
        )

    # Sanitise the parameter return_dom.
    if isinstance(return_dom, _np.ndarray):
        if return_dom.size == 1:
            return_dom = return_dom.ravel()
            return_dom = return_dom.dtype.type(return_dom[0])
    if not isinstance(
        return_dom,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Parameter return_dom must be boolean.&#39;)
    try:
        if return_dom not in {0, False, 1, True}:
            raise ValueError(&#39;Parameter return_dom must be False or True.&#39;)
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Parameter return_dom must be False or True.&#39;)
    try:
        return_dom = _copy.deepcopy(bool(return_dom))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(&#39;Parameter return_dom must be of type bool.&#39;)

    # Compute the boundaries and the dimensions of the rectangle.

    x_min = -a
    x_max = a

    y_min = -b
    y_max = b

    # Initialize the rectangle to all falses.
    Omega = None
    if a &lt; b:
        k = int(_math.ceil(num * a / b))
        a_ = k * b / num
        x_min = -a_
        x_max = a_
        Omega = _np.zeros((k, num), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del a_
    elif a &gt; b:
        k = int(_math.ceil(num * b / a))
        b_ = k * a / num
        y_min = -b_
        y_max = b_
        Omega = _np.zeros((num, k), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del b_
    else:
        Omega = _np.zeros((num, num), dtype = _np.uint8, order = &#39;F&#39;)
    if x_min == 0:
        x_min = 0.0
    if x_max == 0:
        x_max = 0.0
    if y_min == 0:
        y_min = 0.0
    if y_max == 0:
        y_max = 0.0

    # Discretise the rectangle.
    u = _np.linspace(x_min, x_max, num = Omega.shape[0])
    v = _np.linspace(y_min, y_max, num = Omega.shape[1])

    ##  The following code is derived from the implicit ellipsis formula
    ##      b^2 * x^2 + a^2 * y^2 = a^2 * b^2
    ##  because the formula above allows for a and b to be zero.

    # Compute a^2, b^2 and a^2 * b^2.
    a2 = a ** 2
    b2 = b ** 2
    ab2 = a2 * b2

    # Compute the squares of the coordinates inside the rectangle.
    u2 = u ** 2
    v2 = v ** 2

    # Fill the rectangle with trues where needed.
    I = list(range(int(u.size)))
    J = list(range(int(v.size)))
    for i in I:
        for j in J:
            Omega[i, j] = _np.bool8(b2 * u2[i] + a2 * v2[j] &lt; ab2)
        try:
            del j
        except (NameError, UnboundLocalError):
            pass
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    del I
    del J

    # Free the memory.
    del u2
    del v2
    del a2
    del b2
    del ab2
    del u
    del v

    # Return the rectangle and, if needed, the domain&#39;s boundaries.
    return (
        (
            Omega,
            _np.array(
                [[x_min, x_max], [y_min, y_max]],
                dtype = float,
                order = &#39;F&#39;
            )
        ) if return_dom else Omega
    )

def eigenfunc (Omega, k = 1, as_sparse = False, h = None):
    &#34;&#34;&#34;
    Compute the Dirichlet Laplacian eigenfunctions and eigenvalues on Omega.

    Parameters
    ----------
    Omega : (M, N) array_like of booleans
        Discretisation of the rectangle containig the domain.  `Omega` must be a
        2-dimensional non-empty array (`Omega.size &gt; 0`) of integral `dtype` and
        must contain only the values 0 (`False`) and 1 (`True`) such that at
        least one element is non-zero, and no element in the first or the last
        row and in the first or the last column is 1.  As such, `Omega`
        represents an equidistant discretisation of a rectangle containing the
        2-dimensional domain at which the Dirichlet Laplacian eigenvalues and
        eigenfunctions are computed: `Omega[i, j] == 1` if and only if the point
        at the intersection of the `i`-th discretisation line of the x-axis and
        the `j`-th discretisation line of the y-axis is inside the domain.  Note
        that the first dimension represents the x-axis.

    k : int in range [1, Omega.sum()], optional
        Number of Dirichlet Laplacian eigenfunctions and eigenvectors to find at
        the most (default is 1).  The first `k` non-zero real eigenvalues of the
        least magnitude are found and their corresponding real-valued
        eigenfunctions (if they are also real-valued).

    as_sparse : boolean, optional
        If `True`, the eigenvalues and the eigenfunctions are computed using a
        matrix of class `scipy.sparse.spmatrix` and by calling the function
        `scipy.sparse.linalg.eigs`; otherwise the matrix is represented using a
        regular `numpy.ndarray` and the function `numpy.linalg.eig` (default is
        `False`).  The matrix is of shape `(Omega.size, Omega.size)` and at the
        most only `5 * Omega.size` of its elements are non-zero, therefore, if
        `Omega` is large, constructing the `numpy.ndarray` might raise a
        `MemoryError` while constructing the `scipy.sparse.spmatrix` should not.
        On the other hand, the function `numpy.linalg.eig` is much faster than
        the function `scipy.sparse.linalg.eigs`.

    h : None or real in range (0, +inf), optional
        The step of the discretisation (default is `None`).  The Laplacian of
        the function `u` (discretised in the way analogous to the way the domain
        is discretised) at `Omega[i, j]` such that `Omega[i, j] == True` is
        approximated as
        `(u[i + 1, j] + u[i, j + 1] - 4 * u[i, j] + u[i - 1, j] + u[i, j - 1]) / h ** 2`;
        however, if `h` is `None`, only the numerator is used for the
        approximation (as if `h == 1`).  Changing this parameter can result in
        forcing to include some of the eigenvalues if `h` is close to 0 (include
        eigenvalues that would otherwise be close to 0) or to ignore some if `h`
        is large (exclude eigenvalues of small magnitude).

    Returns
    -------
    l : float or (k,) array of floats
        Array containing the real Dirichlet Laplacian eigenvalues sorted
        ascendingly by magnitude.  If `k == 1`, only the first value is returned
        as a scalar (not an array).

    u : (M, N) array of floats or (k, M, N) array of floats
        Array containing the discrete approximations of the real-valued
        Dirichlet Laplacian eigenfunctions.  The &#34;function&#34; `u[i]` corresponds
        to the eigenvalue `l[i]`.  It is guarranteed that all the &#34;functions&#39;&#34;
        values are in the range [-1, 1] and that each &#34;function&#34; is a constant
        zero-valued &#34;function&#34; or it reaches 1 on the domain.  If `k == 1`, only
        the first eigenfunction is returned as a 2-dimensional array (not an
        array of shape `(1, M, N)`).

    Raises
    ------
    TypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.

    RuntimeError
        If no real non-zero eigenvalues corresponding to real-valued
        eigenfunctions are found, an exception of type `RuntimeError` is raised.

    MemoryError
        If `as_sparse` is `False`, an exception of type `MemoryError` might be
        raised --- it is not caught.

    other
        Exceptions raised by the functions `numpy.linalg.eig` or
        `scipy.sparse.linalg.eigs` are not caught.

    &#34;&#34;&#34;

    # Sanitise the parameter Omega.
    if not isinstance(Omega, _np.ndarray):
        if not (hasattr(Omega, &#39;__iter__&#39;) or hasattr(Omega, &#39;__array__&#39;)):
            raise TypeError(&#39;Omega must be an array.&#39;)
        try:
            Omega = _np.array(Omega)
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;Omega must be an array.&#39;)
    if not issubclass(
        Omega.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool_, _np.bool8)
    ):
        raise TypeError(&#39;Omega must be an integral array.&#39;)
    if Omega.ndim != 2:
        raise ValueError(&#39;Omega must be a matrix (a 2-dimensional array).&#39;)
    if not Omega.size:
        raise ValueError(&#39;Omega must be non-empty.&#39;)
    if not _np.isin(Omega.ravel(), [0, 1]).all():
        raise ValueError(&#39;Omega must contain only 0 and 1.&#39;)
    if isinstance(Omega, _np.matrix):
        Omega = Omega.A
    Omega = Omega.astype(_np.bool8)

    # Sanitise the parameter k.
    if isinstance(k, _np.ndarray):
        if k.size == 1:
            k = k.ravel()
            k = k.dtype.type(k[0])
    if not isinstance(k, _numbers.Integral):
        raise TypeError(&#39;Number of eigenvalues/-functions must be integral.&#39;)
    try:
        k = _copy.deepcopy(int(k))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(
            &#39;Number of eigenvalues/-functions must be of type int.&#39;
        )
    if k &lt;= 0:
        raise ValueError(
            &#39;Number of eigenvalues/-functions must be greater than 0.&#39;
        )
    if k &gt; Omega.sum(dtype = int):
        raise ValueError(
            &#39;Number of eigenvalues/-functions must not be larger than the &#39;
            &#39;number of points in the domain.&#39;
        )

    # Sanitise the parameter as_sparse.
    if isinstance(as_sparse, _np.ndarray):
        if as_sparse.size == 1:
            as_sparse = as_sparse.ravel()
            as_sparse = as_sparse.dtype.type(as_sparse[0])
    if not isinstance(
        as_sparse,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Parameter as_sparse must be boolean.&#39;)
    try:
        if as_sparse not in {0, False, 1, True}:
            raise ValueError(&#39;Parameter as_sparse must be False or True.&#39;)
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Parameter as_sparse must be False or True.&#39;)
    try:
        as_sparse = _copy.deepcopy(bool(as_sparse))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(&#39;Parameter as_sparse must be of type bool.&#39;)

    # Sanitise the parameter h.
    if isinstance(h, _np.ndarray):
        if h.size == 1:
            h = h.ravel()
            h = h.dtype.type(h[0])
    if h is not None:
        if not isinstance(h, _numbers.Real):
            raise TypeError(&#39;Step of discretisation must be real.&#39;)
        try:
            h = _copy.deepcopy(float(h))
        except (TypeError, ValueError, AttributeError):
            raise ValueError(&#39;Step of discretisation must be of type float.&#39;)
        if _math.isnan(h) or _math.isinf(h):
            raise ValueError(
                &#39;Step of discretisation must not be NaN or infinite.&#39;
            )
        if h &lt;= 0:
            raise ValueError(&#39;Step of discretisation must be greater than 0.&#39;)

    # Construct the complete Laplacian approximation matrix (no zero-rows).
    d0 = -4 * _np.ones(Omega.size, dtype = float)
    d1 = _np.ones(Omega.size, dtype = float)
    D = _sp.spdiags(
        (d1, d1, d0, d1, d1),
        (-Omega.shape[0], -1, 0, 1, Omega.shape[0]),
        Omega.size,
        Omega.size
    ).tolil(copy = True)
    del d0
    del d1

    # Set the rows of the matrix D corresponding to coordinates outside of Omega
    # to zero.
    I = list(range(int(Omega.shape[0])))
    J = list(range(int(Omega.shape[1])))
    for i in I:
        for j in J:
            if not Omega[i, j]:
                D[i + Omega.shape[0] * j] = 0
        try:
            del j
        except (NameError, UnboundLocalError):
            pass
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    del I
    del J

    # Convert the Laplacian matrix to Compressed Sparse Column matrix dividing
    # it by h^2 if necesarry.
    D = (D if h is None else D / h ** 2).tocsc(copy = True)

    # Compute the inverse of Omega.
    Omega_inv = ~Omega

    # Compute the eigenvalues and eigenvectors of the matrix D.
    l = None
    u = None
    if as_sparse:
        l, u = _eigs(-D, Omega_inv.sum(dtype = int) + k)
    else:
        l, u = _eig(-D.todense(order = &#39;F&#39;))

    # Convert l to a 1-dimensional array and u to a 2-dimensional array.
    l = l.ravel().copy(order = &#39;F&#39;)
    if isinstance(u, _np.matrix):
        u = u.A
    if u.ndim &lt;= 1:
        u = u.reshape((u.size, 1))
    u = u.copy(order = &#39;F&#39;)

    # Free the memory.
    del D

    # Compute the ascending order of the eigenvalues ignoring the values to be
    # ignored (non-real eigenvalues and eigenvectors and zeros if
    # ignore_zeros == True).
    I = None
    l_abs = _np.abs(l)
    u_abs = _np.abs(u)
    I = _np.argsort(l_abs)
    while I.size:
        I = I[~_np.isclose(1, 1 + l_abs[I])].copy(order = &#39;F&#39;)
        l_abs[_np.isclose(1, 1 + l_abs)] = 1
        u_abs[_np.isclose(1, 1 + u_abs)] = 1
        if not I.size:
            break
        I = I[_np.isclose(1, 1 + l[I].imag / l_abs[I])].copy(order = &#39;F&#39;)
        if not I.size:
            break
        I = I[
            _np.isclose(1, 1 + u[:, I].imag / u_abs[:, I]).all(axis = 0).ravel()
        ].copy(order = &#39;F&#39;)

        break
    del l_abs
    del u_abs

    # If no real eigenvalue or eigenvector satisfying were found, raise an
    # exception of type RuntimeError.  Otherwise, if I has more than k entries,
    # set it to hold only its first k elements.
    if not I.size:
        raise RuntimeError(
            &#39;No real eigenvalues and real eigenfunctions were found.&#39;
        )
    elif I.size &gt; k:
        I = I[:k].copy(order = &#39;F&#39;)

    # Convert, reorder and filter the eigenvalues and eigenvectors.
    l = _np.array(l[I].real, dtype = float, copy = True, order = &#39;F&#39;)
    u = _np.array(u[:, I].real, dtype = float, copy = True, order = &#39;F&#39;)

    # Free the memory.
    del I

    # Reshape u to a three-dimensional array.
    u = _np.array(
        [u[:, i].reshape(Omega.shape) for i in range(int(u.shape[1]))],
        dtype = float,
        order = &#39;C&#39;
    )
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    if u.ndim == 2:
        u = u.reshape((1, u.shape[0], u.shape[1]))._copy(order = &#39;C&#39;)

    # Free the memory.
    del Omega

    # Assure no eigenfunction evaluates to a non-zero value outside of Omega,
    # that the non-zero eigenfunctions&#39; range is the subset of the interval
    # [-1, 1] and that the non-zero eigenfunctions reach 1.
    with _warnings.catch_warnings():
        _warnings.filterwarnings(&#39;error&#39;)
        with _np.errstate(divide = &#39;raise&#39;):
            for i in range(int(u.shape[0])):
                u[i, Omega_inv] = 0
                aux_ui = u[i].ravel().copy(order = &#39;C&#39;)
                try:
                    u[i] /= aux_ui[_np.argmax(_np.abs(aux_ui))]
                except (FloatingPointError, ZeroDivisionError, RuntimeWarning):
                    u[i] = 0
                del aux_ui
                u[i, ~u[i].astype(bool)] = 0
            try:
                del i
            except (NameError, UnboundLocalError):
                pass

    # Free the memory.
    del Omega_inv

    # If only the first eigenvalue and function were to be found, convert
    # variables l and u.
    if k == 1:
        l = _copy.deepcopy(float(l[0]))
        u = u[0].copy(order = &#39;F&#39;)

    # Return the eigenvalue(s) and eigenfunction(s).
    return (l, u)

def show_2d_func (u, dom = None, ax = None, how = &#39;contourf&#39;, *args, **kwargs):
    &#34;&#34;&#34;
    Plot a real function on a 2-dimensional rectangular domain.

    Parameters
    ----------
    u : (M, N) array_like of reals or (M, N) array_like of booleans
        Representation of a real function on a discrete rectangle.  Note that
        the first dimension represents the x-axis.

    dom : None or (2, 2) array_like of reals, optional
        Boundaries of the domain (default is `None`).  The function `u` is
        plotted as the funtion on the rectangle defined by the vertices
        (`dom[0, 0]`, `dom[1, 0]`), (`dom[0, 1]`, `dom[1, 0]`),
        (`dom[0, 1]`, `dom[1, 1]`) and (`dom[0, 0]`, `dom[1, 1]`).  The array
        must be sorted ascendingly on the axis 1.  If `None`, the vertices are
        computed such that the rectangle&#39;s center (the intersection of its
        diagonals) is at (0, 0), the ratio of its width by its height is equal
        to `M / N` and that the narrower dimension spans from -1 to 1.

    ax : None or matplotlib.axes.Axes or mpl_toolkits.mplot3d.Axes3D, optional
        Axis at which the surface is plotted (default is `None`).  If `None`,
        `matplotlib.pyplot.gca()` is used.

    how : str, optional
        Type of the plot (default is `&#39;contourf&#39;`).  The function is plotted by
        calling `ax.__getattribute__(how)(...)`.

    *args, **kwargs
        Additional arguments passed to `ax.__getattribute__(how)(...)` after the
        first three arguments (`X`, `Y` and `Z` data).

    Returns
    -------
    ax : matplotlib.axes.Axes or mpl_toolkits.mplot3d.Axes3D
        Axis at which the function is plotted.

    Raises
    ------
    TTypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.  If any of the dimensions of
        the array `u` is (strictly) less than 2, an exception of type
        `ValueError` is raised.  If `dom` is an array, it must be sorted
        ascendingly on axis 1 (its rows must be strictly increasing sequences);
        otherwise an exception of type `ValueError` is raised.

    other
        If the command `ax.__getattribute__(how)(X, Y, Z, *args, **kwargs)`
        (where the shapes and values of `X`, `Y` and `Z` are valid if the plot
        type defined by the parameter `how` accepts the same arguments as
        `matplotlib.axes.Axes.contourf`) raises an exception, it is not caught.
        Not even `AttributeError` is caught if `how` is not a valid plot type.

    &#34;&#34;&#34;

    # Sanitise the parameter u.
    if not isinstance(u, _np.ndarray):
        if not (hasattr(u, &#39;__iter__&#39;) or hasattr(u, &#39;__array__&#39;)):
            raise TypeError(&#39;u must be an array.&#39;)
        try:
            u = _np.array(u)
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;u must be an array.&#39;)
    if not issubclass(
        u.dtype.type,
        (_numbers.Real, int, bool, _np.bool, _np.bool_, _np.bool8)
    ):
        raise TypeError(&#39;u must be a real-valued or a boolean array.&#39;)
    if u.ndim != 2:
        raise ValueError(&#39;u must be a matrix (2-dimensional array).&#39;)
    if not u.size:
        raise ValueError(&#39;u must be non-empty.&#39;)
    if u.shape[0] &lt; 2 or u.shape[1] &lt; 2:
        raise ValueError(&#39;Each dimension of u must be at least 2.&#39;)
    if _np.isnan(u).any() or _np.isinf(u).any():
        raise ValueError(&#39;u must not contain NaN or infinite values.&#39;)
    if isinstance(u, _np.matrix):
        u = u.A

    # Sanitise the parameter dom.
    if dom is None:
        dom = _np.array([[-1.0, 1.0], [-1.0, 1.0]], dtype = float, order = &#39;C&#39;)
        if u.shape[0] &gt; u.shape[1]:
            q = float(u.shape[0]) / float(u.shape[1])
            dom[0, 0] = -q
            dom[0, 1] = q
            del q
        elif u.shape[1] &gt; u.shape[0]:
            q = float(u.shape[1]) / float(u.shape[0])
            dom[1, 0] = -q
            dom[1, 1] = q
            del q
    else:
        if not isinstance(dom, _np.ndarray):
            if not (hasattr(dom, &#39;__iter__&#39;) or hasattr(dom, &#39;__array__&#39;)):
                raise TypeError(&#39;Domain must be a numpy array.&#39;)
            try:
                dom = _np.array(dom)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;Domain must be a numpy array.&#39;)
        if not issubclass(dom.dtype.type, _numbers.Real):
            raise TypeError(&#39;Domain must be an real-valued array.&#39;)
        if dom.ndim != 2:
            raise ValueError(&#39;Domain must be a matrix (a 2-dimensional array).&#39;)
        if not dom.shape == (2, 2):
            raise ValueError(&#39;Domain must be a 2 x 2 array.&#39;)
        if _np.isnan(dom).any() or _np.isinf(dom).any():
            raise ValueError(&#39;Domain must not contain NaN or infinite values.&#39;)
        if not (dom[:, 0] &lt; dom[:, 1]).all():
            raise ValueError(&#39;Domain must be sorted ascendingly on axis 1.&#39;)
        if isinstance(dom, _np.matrix):
            dom = dom.A

    # Compute the domain.
    dom = tuple(
        _np.meshgrid(
            _np.linspace(dom[0, 0], dom[0, 1], num = u.shape[0], dtype = float),
            _np.linspace(dom[1, 0], dom[1, 1], num = u.shape[1], dtype = float),
            indexing = &#39;ij&#39;
        )
    )

    # Sanitise the parameter ax.
    if ax is None:
        ax = _plt.gca()
    else:
        if isinstance(ax, _np.ndarray):
            if ax.size == 1:
                ax = ax.ravel()
                ax = ax.dtype.type(ax[0])
        if not isinstance(ax, (_Axes, _Axes3D)):
            raise TypeError(
                &#39;Axis must be of type matplotlib.axes.Axes or &#39;
                &#39;mpl_toolkits.mplot3d.Axes3D.&#39;
            )

    # Sanitise the parameter how.
    if isinstance(how, _np.ndarray):
        if how.size == 1:
            how = how.ravel()
            how = how.dtype.type(how[0])
    if not (
        isinstance(how, _six.string_types) or
        isinstance(how, _six.text_type) or
        isinstance(how, _six.binary_type) or
        isinstance(
            how,
            (
                _np.str,
                _np.str_,
                _np.unicode,
                _np.unicode_,
                _np.string_,
                _np.bytes_
            )
        )
    ):
        raise TypeError(&#39;Plot type must be a string.&#39;)
    try:
        how = _copy.deepcopy(str(how))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Plot type must be of type str.&#39;)

    # Plot the plot.
    ax.__getattribute__(how)(dom[0], dom[1], u, *args, **kwargs)

    # Return the axis.
    return ax</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="script.eigenfunc"><code class="name flex">
<span>def <span class="ident">eigenfunc</span></span>(<span>Omega, k=1, as_sparse=False, h=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the Dirichlet Laplacian eigenfunctions and eigenvalues on Omega.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Omega</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array_like</code> of <code>booleans</code></dt>
<dd>Discretisation of the rectangle containig the domain.
<code>Omega</code> must be a
2-dimensional non-empty array (<code>Omega.size &gt; 0</code>) of integral <code>dtype</code> and
must contain only the values 0 (<code>False</code>) and 1 (<code>True</code>) such that at
least one element is non-zero, and no element in the first or the last
row and in the first or the last column is 1.
As such, <code>Omega</code>
represents an equidistant discretisation of a rectangle containing the
2-dimensional domain at which the Dirichlet Laplacian eigenvalues and
eigenfunctions are computed: <code>Omega[i, j] == 1</code> if and only if the point
at the intersection of the <code>i</code>-th discretisation line of the x-axis and
the <code>j</code>-th discretisation line of the y-axis is inside the domain.
Note
that the first dimension represents the x-axis.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code> <code>in</code> <code>range</code> [<code>1</code>, <code>Omega.sum</code>()], optional</dt>
<dd>Number of Dirichlet Laplacian eigenfunctions and eigenvectors to find at
the most (default is 1).
The first <code>k</code> non-zero real eigenvalues of the
least magnitude are found and their corresponding real-valued
eigenfunctions (if they are also real-valued).</dd>
<dt><strong><code>as_sparse</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>If <code>True</code>, the eigenvalues and the eigenfunctions are computed using a
matrix of class <code>scipy.sparse.spmatrix</code> and by calling the function
<code>scipy.sparse.linalg.eigs</code>; otherwise the matrix is represented using a
regular <code>numpy.ndarray</code> and the function <code>numpy.linalg.eig</code> (default is
<code>False</code>).
The matrix is of shape <code>(Omega.size, Omega.size)</code> and at the
most only <code>5 * Omega.size</code> of its elements are non-zero, therefore, if
<code>Omega</code> is large, constructing the <code>numpy.ndarray</code> might raise a
<code>MemoryError</code> while constructing the <code>scipy.sparse.spmatrix</code> should not.
On the other hand, the function <code>numpy.linalg.eig</code> is much faster than
the function <code>scipy.sparse.linalg.eigs</code>.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>None</code> or <code>real</code> <code>in</code> <code>range</code> (<code>0</code>, +<code>inf</code>), optional</dt>
<dd>The step of the discretisation (default is <code>None</code>).
The Laplacian of
the function <code>u</code> (discretised in the way analogous to the way the domain
is discretised) at <code>Omega[i, j]</code> such that <code>Omega[i, j] == True</code> is
approximated as
<code>(u[i + 1, j] + u[i, j + 1] - 4 * u[i, j] + u[i - 1, j] + u[i, j - 1]) / h ** 2</code>;
however, if <code>h</code> is <code>None</code>, only the numerator is used for the
approximation (as if <code>h == 1</code>).
Changing this parameter can result in
forcing to include some of the eigenvalues if <code>h</code> is close to 0 (include
eigenvalues that would otherwise be close to 0) or to ignore some if <code>h</code>
is large (exclude eigenvalues of small magnitude).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code> or (<code>k</code>,) <code>array</code> of <code>floats</code></dt>
<dd>Array containing the real Dirichlet Laplacian eigenvalues sorted
ascendingly by magnitude.
If <code>k == 1</code>, only the first value is returned
as a scalar (not an array).</dd>
<dt><strong><code>u</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code> of <code>floats</code> or (<code>k</code>, <code>M</code>, <code>N</code>) <code>array</code> of <code>floats</code></dt>
<dd>Array containing the discrete approximations of the real-valued
Dirichlet Laplacian eigenfunctions.
The "function" <code>u[i]</code> corresponds
to the eigenvalue <code>l[i]</code>.
It is guarranteed that all the "functions'"
values are in the range [-1, 1] and that each "function" is a constant
zero-valued "function" or it reaches 1 on the domain.
If <code>k == 1</code>, only
the first eigenfunction is returned as a 2-dimensional array (not an
array of shape <code>(1, M, N)</code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If any of the parameters is not of a supported type or <code>dtype</code>, an
exception of type <code>TypeError</code> is raised.</dd>
<dt><code>ValueError</code></dt>
<dd>If any of the parameters is not of a supported shape or value, an
exception of type <code>ValueError</code> is raised.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If no real non-zero eigenvalues corresponding to real-valued
eigenfunctions are found, an exception of type <code>RuntimeError</code> is raised.</dd>
<dt><code>MemoryError</code></dt>
<dd>If <code>as_sparse</code> is <code>False</code>, an exception of type <code>MemoryError</code> might be
raised &mdash; it is not caught.</dd>
<dt><code>other</code></dt>
<dd>Exceptions raised by the functions <code>numpy.linalg.eig</code> or
<code>scipy.sparse.linalg.eigs</code> are not caught.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def eigenfunc (Omega, k = 1, as_sparse = False, h = None):
    &#34;&#34;&#34;
    Compute the Dirichlet Laplacian eigenfunctions and eigenvalues on Omega.

    Parameters
    ----------
    Omega : (M, N) array_like of booleans
        Discretisation of the rectangle containig the domain.  `Omega` must be a
        2-dimensional non-empty array (`Omega.size &gt; 0`) of integral `dtype` and
        must contain only the values 0 (`False`) and 1 (`True`) such that at
        least one element is non-zero, and no element in the first or the last
        row and in the first or the last column is 1.  As such, `Omega`
        represents an equidistant discretisation of a rectangle containing the
        2-dimensional domain at which the Dirichlet Laplacian eigenvalues and
        eigenfunctions are computed: `Omega[i, j] == 1` if and only if the point
        at the intersection of the `i`-th discretisation line of the x-axis and
        the `j`-th discretisation line of the y-axis is inside the domain.  Note
        that the first dimension represents the x-axis.

    k : int in range [1, Omega.sum()], optional
        Number of Dirichlet Laplacian eigenfunctions and eigenvectors to find at
        the most (default is 1).  The first `k` non-zero real eigenvalues of the
        least magnitude are found and their corresponding real-valued
        eigenfunctions (if they are also real-valued).

    as_sparse : boolean, optional
        If `True`, the eigenvalues and the eigenfunctions are computed using a
        matrix of class `scipy.sparse.spmatrix` and by calling the function
        `scipy.sparse.linalg.eigs`; otherwise the matrix is represented using a
        regular `numpy.ndarray` and the function `numpy.linalg.eig` (default is
        `False`).  The matrix is of shape `(Omega.size, Omega.size)` and at the
        most only `5 * Omega.size` of its elements are non-zero, therefore, if
        `Omega` is large, constructing the `numpy.ndarray` might raise a
        `MemoryError` while constructing the `scipy.sparse.spmatrix` should not.
        On the other hand, the function `numpy.linalg.eig` is much faster than
        the function `scipy.sparse.linalg.eigs`.

    h : None or real in range (0, +inf), optional
        The step of the discretisation (default is `None`).  The Laplacian of
        the function `u` (discretised in the way analogous to the way the domain
        is discretised) at `Omega[i, j]` such that `Omega[i, j] == True` is
        approximated as
        `(u[i + 1, j] + u[i, j + 1] - 4 * u[i, j] + u[i - 1, j] + u[i, j - 1]) / h ** 2`;
        however, if `h` is `None`, only the numerator is used for the
        approximation (as if `h == 1`).  Changing this parameter can result in
        forcing to include some of the eigenvalues if `h` is close to 0 (include
        eigenvalues that would otherwise be close to 0) or to ignore some if `h`
        is large (exclude eigenvalues of small magnitude).

    Returns
    -------
    l : float or (k,) array of floats
        Array containing the real Dirichlet Laplacian eigenvalues sorted
        ascendingly by magnitude.  If `k == 1`, only the first value is returned
        as a scalar (not an array).

    u : (M, N) array of floats or (k, M, N) array of floats
        Array containing the discrete approximations of the real-valued
        Dirichlet Laplacian eigenfunctions.  The &#34;function&#34; `u[i]` corresponds
        to the eigenvalue `l[i]`.  It is guarranteed that all the &#34;functions&#39;&#34;
        values are in the range [-1, 1] and that each &#34;function&#34; is a constant
        zero-valued &#34;function&#34; or it reaches 1 on the domain.  If `k == 1`, only
        the first eigenfunction is returned as a 2-dimensional array (not an
        array of shape `(1, M, N)`).

    Raises
    ------
    TypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.

    RuntimeError
        If no real non-zero eigenvalues corresponding to real-valued
        eigenfunctions are found, an exception of type `RuntimeError` is raised.

    MemoryError
        If `as_sparse` is `False`, an exception of type `MemoryError` might be
        raised --- it is not caught.

    other
        Exceptions raised by the functions `numpy.linalg.eig` or
        `scipy.sparse.linalg.eigs` are not caught.

    &#34;&#34;&#34;

    # Sanitise the parameter Omega.
    if not isinstance(Omega, _np.ndarray):
        if not (hasattr(Omega, &#39;__iter__&#39;) or hasattr(Omega, &#39;__array__&#39;)):
            raise TypeError(&#39;Omega must be an array.&#39;)
        try:
            Omega = _np.array(Omega)
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;Omega must be an array.&#39;)
    if not issubclass(
        Omega.dtype.type,
        (_numbers.Integral, int, bool, _np.bool, _np.bool_, _np.bool8)
    ):
        raise TypeError(&#39;Omega must be an integral array.&#39;)
    if Omega.ndim != 2:
        raise ValueError(&#39;Omega must be a matrix (a 2-dimensional array).&#39;)
    if not Omega.size:
        raise ValueError(&#39;Omega must be non-empty.&#39;)
    if not _np.isin(Omega.ravel(), [0, 1]).all():
        raise ValueError(&#39;Omega must contain only 0 and 1.&#39;)
    if isinstance(Omega, _np.matrix):
        Omega = Omega.A
    Omega = Omega.astype(_np.bool8)

    # Sanitise the parameter k.
    if isinstance(k, _np.ndarray):
        if k.size == 1:
            k = k.ravel()
            k = k.dtype.type(k[0])
    if not isinstance(k, _numbers.Integral):
        raise TypeError(&#39;Number of eigenvalues/-functions must be integral.&#39;)
    try:
        k = _copy.deepcopy(int(k))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(
            &#39;Number of eigenvalues/-functions must be of type int.&#39;
        )
    if k &lt;= 0:
        raise ValueError(
            &#39;Number of eigenvalues/-functions must be greater than 0.&#39;
        )
    if k &gt; Omega.sum(dtype = int):
        raise ValueError(
            &#39;Number of eigenvalues/-functions must not be larger than the &#39;
            &#39;number of points in the domain.&#39;
        )

    # Sanitise the parameter as_sparse.
    if isinstance(as_sparse, _np.ndarray):
        if as_sparse.size == 1:
            as_sparse = as_sparse.ravel()
            as_sparse = as_sparse.dtype.type(as_sparse[0])
    if not isinstance(
        as_sparse,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Parameter as_sparse must be boolean.&#39;)
    try:
        if as_sparse not in {0, False, 1, True}:
            raise ValueError(&#39;Parameter as_sparse must be False or True.&#39;)
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Parameter as_sparse must be False or True.&#39;)
    try:
        as_sparse = _copy.deepcopy(bool(as_sparse))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(&#39;Parameter as_sparse must be of type bool.&#39;)

    # Sanitise the parameter h.
    if isinstance(h, _np.ndarray):
        if h.size == 1:
            h = h.ravel()
            h = h.dtype.type(h[0])
    if h is not None:
        if not isinstance(h, _numbers.Real):
            raise TypeError(&#39;Step of discretisation must be real.&#39;)
        try:
            h = _copy.deepcopy(float(h))
        except (TypeError, ValueError, AttributeError):
            raise ValueError(&#39;Step of discretisation must be of type float.&#39;)
        if _math.isnan(h) or _math.isinf(h):
            raise ValueError(
                &#39;Step of discretisation must not be NaN or infinite.&#39;
            )
        if h &lt;= 0:
            raise ValueError(&#39;Step of discretisation must be greater than 0.&#39;)

    # Construct the complete Laplacian approximation matrix (no zero-rows).
    d0 = -4 * _np.ones(Omega.size, dtype = float)
    d1 = _np.ones(Omega.size, dtype = float)
    D = _sp.spdiags(
        (d1, d1, d0, d1, d1),
        (-Omega.shape[0], -1, 0, 1, Omega.shape[0]),
        Omega.size,
        Omega.size
    ).tolil(copy = True)
    del d0
    del d1

    # Set the rows of the matrix D corresponding to coordinates outside of Omega
    # to zero.
    I = list(range(int(Omega.shape[0])))
    J = list(range(int(Omega.shape[1])))
    for i in I:
        for j in J:
            if not Omega[i, j]:
                D[i + Omega.shape[0] * j] = 0
        try:
            del j
        except (NameError, UnboundLocalError):
            pass
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    del I
    del J

    # Convert the Laplacian matrix to Compressed Sparse Column matrix dividing
    # it by h^2 if necesarry.
    D = (D if h is None else D / h ** 2).tocsc(copy = True)

    # Compute the inverse of Omega.
    Omega_inv = ~Omega

    # Compute the eigenvalues and eigenvectors of the matrix D.
    l = None
    u = None
    if as_sparse:
        l, u = _eigs(-D, Omega_inv.sum(dtype = int) + k)
    else:
        l, u = _eig(-D.todense(order = &#39;F&#39;))

    # Convert l to a 1-dimensional array and u to a 2-dimensional array.
    l = l.ravel().copy(order = &#39;F&#39;)
    if isinstance(u, _np.matrix):
        u = u.A
    if u.ndim &lt;= 1:
        u = u.reshape((u.size, 1))
    u = u.copy(order = &#39;F&#39;)

    # Free the memory.
    del D

    # Compute the ascending order of the eigenvalues ignoring the values to be
    # ignored (non-real eigenvalues and eigenvectors and zeros if
    # ignore_zeros == True).
    I = None
    l_abs = _np.abs(l)
    u_abs = _np.abs(u)
    I = _np.argsort(l_abs)
    while I.size:
        I = I[~_np.isclose(1, 1 + l_abs[I])].copy(order = &#39;F&#39;)
        l_abs[_np.isclose(1, 1 + l_abs)] = 1
        u_abs[_np.isclose(1, 1 + u_abs)] = 1
        if not I.size:
            break
        I = I[_np.isclose(1, 1 + l[I].imag / l_abs[I])].copy(order = &#39;F&#39;)
        if not I.size:
            break
        I = I[
            _np.isclose(1, 1 + u[:, I].imag / u_abs[:, I]).all(axis = 0).ravel()
        ].copy(order = &#39;F&#39;)

        break
    del l_abs
    del u_abs

    # If no real eigenvalue or eigenvector satisfying were found, raise an
    # exception of type RuntimeError.  Otherwise, if I has more than k entries,
    # set it to hold only its first k elements.
    if not I.size:
        raise RuntimeError(
            &#39;No real eigenvalues and real eigenfunctions were found.&#39;
        )
    elif I.size &gt; k:
        I = I[:k].copy(order = &#39;F&#39;)

    # Convert, reorder and filter the eigenvalues and eigenvectors.
    l = _np.array(l[I].real, dtype = float, copy = True, order = &#39;F&#39;)
    u = _np.array(u[:, I].real, dtype = float, copy = True, order = &#39;F&#39;)

    # Free the memory.
    del I

    # Reshape u to a three-dimensional array.
    u = _np.array(
        [u[:, i].reshape(Omega.shape) for i in range(int(u.shape[1]))],
        dtype = float,
        order = &#39;C&#39;
    )
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    if u.ndim == 2:
        u = u.reshape((1, u.shape[0], u.shape[1]))._copy(order = &#39;C&#39;)

    # Free the memory.
    del Omega

    # Assure no eigenfunction evaluates to a non-zero value outside of Omega,
    # that the non-zero eigenfunctions&#39; range is the subset of the interval
    # [-1, 1] and that the non-zero eigenfunctions reach 1.
    with _warnings.catch_warnings():
        _warnings.filterwarnings(&#39;error&#39;)
        with _np.errstate(divide = &#39;raise&#39;):
            for i in range(int(u.shape[0])):
                u[i, Omega_inv] = 0
                aux_ui = u[i].ravel().copy(order = &#39;C&#39;)
                try:
                    u[i] /= aux_ui[_np.argmax(_np.abs(aux_ui))]
                except (FloatingPointError, ZeroDivisionError, RuntimeWarning):
                    u[i] = 0
                del aux_ui
                u[i, ~u[i].astype(bool)] = 0
            try:
                del i
            except (NameError, UnboundLocalError):
                pass

    # Free the memory.
    del Omega_inv

    # If only the first eigenvalue and function were to be found, convert
    # variables l and u.
    if k == 1:
        l = _copy.deepcopy(float(l[0]))
        u = u[0].copy(order = &#39;F&#39;)

    # Return the eigenvalue(s) and eigenfunction(s).
    return (l, u)</code></pre>
</details>
</dd>
<dt id="script.ellips"><code class="name flex">
<span>def <span class="ident">ellips</span></span>(<span>a=1, b=None, num=50, return_dom=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the discretisation of a rectangle containing an open ellipsis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>real</code> <code>in</code> <code>range</code> [<code>0</code>, +<code>inf</code>), optional</dt>
<dd>The width of the ellipsis (default is 1).
If a value is passed as the
parameter <code>a</code> and <code>None</code> is passed as <code>b</code>, the value of <code>a</code> does not
affect the resulting rectangle (probably except for extremely large or
extremely small values, and definitely except for zero versus non-zero
values), therefore the parameter <code>a</code> is optional.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>None</code> or <code>real</code> <code>in</code> <code>range</code> [<code>0</code>, +<code>inf</code>), optional</dt>
<dd>The height of the ellipsis (default is <code>None</code>).
If <code>None</code>, height will
be equal to width.</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code> <code>in</code> <code>range</code> [<code>2</code>, +<code>inf</code>), optional</dt>
<dd>The number of discretisation points used to discretise the wider
dimension of the resulting rectangle (default is 50).</dd>
<dt><strong><code>return_dom</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>If <code>True</code>, the rectangle's boundaries are returned as well as the
rectangle itself (default is <code>False</code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Omega</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code> of <code>booleans</code></dt>
<dd>Array of trues and falses representing the discretisation of the
rectangle containing the closure of the ellipsis.
The rectangle will
span from <code>-a</code> to <code>a</code> on its first dimension, and from <code>-b</code> to <code>b</code> on
its second dimension, and the equality <code>max(M, N) == num</code> will be true.
If the ratio <code>a</code> / <code>b</code> (allowing for the denominator to be equal to 0)
cannot be written as a rational number p / q such that
max(p, q) = <code>num</code>, then the narrower dimension of the rectangle is
stretched, possibly resulting in a few additional rows/columns filled
with falses &mdash; this is done so that the discretisation step is equal on
both the x-axis and the y-axis.
The values of <code>Omega</code> are defined as:
<code>Omega[i, j] == True</code> if and only if the point at the intersection of
the <code>i</code>-th discretisation line of the x-axis and the <code>j</code>-th
discretisation line of the y-axis is inside the open ellipsis.
Note
that the first dimension represents the x-axis.</dd>
<dt><strong><code>dom</code></strong> :&ensp;(<code>2</code>, <code>2</code>) <code>array</code> of <code>floats</code></dt>
<dd>The rectangle that is returned spans from <code>dom[0, 0]</code> to <code>dom[0, 1]</code> on
the x-axis, and from <code>dom[1, 0]</code> to <code>dom[1, 1]</code> on the y-axis.
It is
guarranteed that <code>(dom[:, 0] &lt;= dom[:, 1]).all()</code> is <code>True</code>.
This is
returned only if the parameter <code>return_dom</code> is <code>True</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If any of the parameters is not of a supported type or <code>dtype</code>, an
exception of type <code>TypeError</code> is raised.</dd>
<dt><code>ValueError</code></dt>
<dd>If any of the parameters is not of a supported shape or value, an
exception of type <code>ValueError</code> is raised.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ellips (a = 1, b = None, num = 50, return_dom = False):
    &#34;&#34;&#34;
    Compute the discretisation of a rectangle containing an open ellipsis.

    Parameters
    ----------
    a : real in range [0, +inf), optional
        The width of the ellipsis (default is 1).  If a value is passed as the
        parameter `a` and `None` is passed as `b`, the value of `a` does not
        affect the resulting rectangle (probably except for extremely large or
        extremely small values, and definitely except for zero versus non-zero
        values), therefore the parameter `a` is optional.

    b : None or real in range [0, +inf), optional
        The height of the ellipsis (default is `None`).  If `None`, height will
        be equal to width.

    num : int in range [2, +inf), optional
        The number of discretisation points used to discretise the wider
        dimension of the resulting rectangle (default is 50).

    return_dom : boolean, optional
        If `True`, the rectangle&#39;s boundaries are returned as well as the
        rectangle itself (default is `False`).

    Returns
    -------
    Omega : (M, N) array of booleans
        Array of trues and falses representing the discretisation of the
        rectangle containing the closure of the ellipsis.  The rectangle will
        span from `-a` to `a` on its first dimension, and from `-b` to `b` on
        its second dimension, and the equality `max(M, N) == num` will be true.
        If the ratio `a` / `b` (allowing for the denominator to be equal to 0)
        cannot be written as a rational number p / q such that
        max(p, q) = `num`, then the narrower dimension of the rectangle is
        stretched, possibly resulting in a few additional rows/columns filled
        with falses --- this is done so that the discretisation step is equal on
        both the x-axis and the y-axis.  The values of `Omega` are defined as:
        `Omega[i, j] == True` if and only if the point at the intersection of
        the `i`-th discretisation line of the x-axis and the `j`-th
        discretisation line of the y-axis is inside the open ellipsis.  Note
        that the first dimension represents the x-axis.

    dom : (2, 2) array of floats
        The rectangle that is returned spans from `dom[0, 0]` to `dom[0, 1]` on
        the x-axis, and from `dom[1, 0]` to `dom[1, 1]` on the y-axis.  It is
        guarranteed that `(dom[:, 0] &lt;= dom[:, 1]).all()` is `True`.  This is
        returned only if the parameter `return_dom` is `True`.

    Raises
    ------
    TypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.

    &#34;&#34;&#34;

    # Sanitise the parameter a.
    if isinstance(a, _np.ndarray):
        if a.size == 1:
            a = a.ravel()
            a = a.dtype.type(a[0])
    if not isinstance(a, _numbers.Real):
        raise TypeError(&#39;a must be real.&#39;)
    try:
        a = _copy.deepcopy(float(a))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;a must be of type float.&#39;)
    if _math.isnan(a) or _math.isinf(a):
        raise ValueError(&#39;a must be non-NaN and finite.&#39;)
    if a &lt; 0:
        raise ValueError(&#39;a must not be negative.&#39;)
    if a == 0:
        a = 0.0

    # If b is None, define the height of the ellipsis.
    if b is None:
        b = a

    # Sanitise the parameter b.
    if isinstance(b, _np.ndarray):
        if b.size == 1:
            b = b.ravel()
            b = b.dtype.type(b[0])
    if not isinstance(b, _numbers.Real):
        raise TypeError(&#39;b must be real.&#39;)
    try:
        b = _copy.deepcopy(float(b))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;b must be of type float.&#39;)
    if _math.isnan(b) or _math.isinf(b):
        raise ValueError(&#39;b must be non-NaN and finite.&#39;)
    if b &lt; 0:
        raise ValueError(&#39;b must not be negative.&#39;)
    if b == 0:
        b = 0.0

    # Sanitise the parameter num.
    if isinstance(num, _np.ndarray):
        if num.size == 1:
            num = num.ravel()
            num = num.dtype.type(num[0])
    if not isinstance(num, _numbers.Integral):
        raise TypeError(&#39;Number of discretisation points must be integral.&#39;)
    try:
        num = _copy.deepcopy(int(num))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Number of discretisation points must be of type int.&#39;)
    if num &lt; 2:
        raise ValueError(
            &#39;Number of discretisation points must be greater than 1.&#39;
        )

    # Sanitise the parameter return_dom.
    if isinstance(return_dom, _np.ndarray):
        if return_dom.size == 1:
            return_dom = return_dom.ravel()
            return_dom = return_dom.dtype.type(return_dom[0])
    if not isinstance(
        return_dom,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Parameter return_dom must be boolean.&#39;)
    try:
        if return_dom not in {0, False, 1, True}:
            raise ValueError(&#39;Parameter return_dom must be False or True.&#39;)
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Parameter return_dom must be False or True.&#39;)
    try:
        return_dom = _copy.deepcopy(bool(return_dom))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(&#39;Parameter return_dom must be of type bool.&#39;)

    # Compute the boundaries and the dimensions of the rectangle.

    x_min = -a
    x_max = a

    y_min = -b
    y_max = b

    # Initialize the rectangle to all falses.
    Omega = None
    if a &lt; b:
        k = int(_math.ceil(num * a / b))
        a_ = k * b / num
        x_min = -a_
        x_max = a_
        Omega = _np.zeros((k, num), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del a_
    elif a &gt; b:
        k = int(_math.ceil(num * b / a))
        b_ = k * a / num
        y_min = -b_
        y_max = b_
        Omega = _np.zeros((num, k), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del b_
    else:
        Omega = _np.zeros((num, num), dtype = _np.uint8, order = &#39;F&#39;)
    if x_min == 0:
        x_min = 0.0
    if x_max == 0:
        x_max = 0.0
    if y_min == 0:
        y_min = 0.0
    if y_max == 0:
        y_max = 0.0

    # Discretise the rectangle.
    u = _np.linspace(x_min, x_max, num = Omega.shape[0])
    v = _np.linspace(y_min, y_max, num = Omega.shape[1])

    ##  The following code is derived from the implicit ellipsis formula
    ##      b^2 * x^2 + a^2 * y^2 = a^2 * b^2
    ##  because the formula above allows for a and b to be zero.

    # Compute a^2, b^2 and a^2 * b^2.
    a2 = a ** 2
    b2 = b ** 2
    ab2 = a2 * b2

    # Compute the squares of the coordinates inside the rectangle.
    u2 = u ** 2
    v2 = v ** 2

    # Fill the rectangle with trues where needed.
    I = list(range(int(u.size)))
    J = list(range(int(v.size)))
    for i in I:
        for j in J:
            Omega[i, j] = _np.bool8(b2 * u2[i] + a2 * v2[j] &lt; ab2)
        try:
            del j
        except (NameError, UnboundLocalError):
            pass
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    del I
    del J

    # Free the memory.
    del u2
    del v2
    del a2
    del b2
    del ab2
    del u
    del v

    # Return the rectangle and, if needed, the domain&#39;s boundaries.
    return (
        (
            Omega,
            _np.array(
                [[x_min, x_max], [y_min, y_max]],
                dtype = float,
                order = &#39;F&#39;
            )
        ) if return_dom else Omega
    )</code></pre>
</details>
</dd>
<dt id="script.show_2d_func"><code class="name flex">
<span>def <span class="ident">show_2d_func</span></span>(<span>u, dom=None, ax=None, how='contourf', *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot a real function on a 2-dimensional rectangular domain.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array_like</code> of <code>reals</code> or (<code>M</code>, <code>N</code>) <code>array_like</code> of <code>booleans</code></dt>
<dd>Representation of a real function on a discrete rectangle.
Note that
the first dimension represents the x-axis.</dd>
<dt><strong><code>dom</code></strong> :&ensp;<code>None</code> or (<code>2</code>, <code>2</code>) <code>array_like</code> of <code>reals</code>, optional</dt>
<dd>Boundaries of the domain (default is <code>None</code>).
The function <code>u</code> is
plotted as the funtion on the rectangle defined by the vertices
(<code>dom[0, 0]</code>, <code>dom[1, 0]</code>), (<code>dom[0, 1]</code>, <code>dom[1, 0]</code>),
(<code>dom[0, 1]</code>, <code>dom[1, 1]</code>) and (<code>dom[0, 0]</code>, <code>dom[1, 1]</code>).
The array
must be sorted ascendingly on the axis 1.
If <code>None</code>, the vertices are
computed such that the rectangle's center (the intersection of its
diagonals) is at (0, 0), the ratio of its width by its height is equal
to <code>M / N</code> and that the narrower dimension spans from -1 to 1.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>None</code> or <code>matplotlib.axes.Axes</code> or <code>mpl_toolkits.mplot3d.Axes3D</code>, optional</dt>
<dd>Axis at which the surface is plotted (default is <code>None</code>).
If <code>None</code>,
<code>matplotlib.pyplot.gca()</code> is used.</dd>
<dt><strong><code>how</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of the plot (default is <code>'contourf'</code>).
The function is plotted by
calling <code>ax.__getattribute__(how)(...)</code>.</dd>
<dt><strong><code>*args</code></strong>, <strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to <code>ax.__getattribute__(how)(...)</code> after the
first three arguments (<code>X</code>, <code>Y</code> and <code>Z</code> data).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code> or <code>mpl_toolkits.mplot3d.Axes3D</code></dt>
<dd>Axis at which the function is plotted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TTypeError</code></dt>
<dd>If any of the parameters is not of a supported type or <code>dtype</code>, an
exception of type <code>TypeError</code> is raised.</dd>
<dt><code>ValueError</code></dt>
<dd>If any of the parameters is not of a supported shape or value, an
exception of type <code>ValueError</code> is raised.
If any of the dimensions of
the array <code>u</code> is (strictly) less than 2, an exception of type
<code>ValueError</code> is raised.
If <code>dom</code> is an array, it must be sorted
ascendingly on axis 1 (its rows must be strictly increasing sequences);
otherwise an exception of type <code>ValueError</code> is raised.</dd>
<dt><code>other</code></dt>
<dd>If the command <code>ax.__getattribute__(how)(X, Y, Z, *args, **kwargs)</code>
(where the shapes and values of <code>X</code>, <code>Y</code> and <code>Z</code> are valid if the plot
type defined by the parameter <code>how</code> accepts the same arguments as
<code>matplotlib.axes.Axes.contourf</code>) raises an exception, it is not caught.
Not even <code>AttributeError</code> is caught if <code>how</code> is not a valid plot type.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show_2d_func (u, dom = None, ax = None, how = &#39;contourf&#39;, *args, **kwargs):
    &#34;&#34;&#34;
    Plot a real function on a 2-dimensional rectangular domain.

    Parameters
    ----------
    u : (M, N) array_like of reals or (M, N) array_like of booleans
        Representation of a real function on a discrete rectangle.  Note that
        the first dimension represents the x-axis.

    dom : None or (2, 2) array_like of reals, optional
        Boundaries of the domain (default is `None`).  The function `u` is
        plotted as the funtion on the rectangle defined by the vertices
        (`dom[0, 0]`, `dom[1, 0]`), (`dom[0, 1]`, `dom[1, 0]`),
        (`dom[0, 1]`, `dom[1, 1]`) and (`dom[0, 0]`, `dom[1, 1]`).  The array
        must be sorted ascendingly on the axis 1.  If `None`, the vertices are
        computed such that the rectangle&#39;s center (the intersection of its
        diagonals) is at (0, 0), the ratio of its width by its height is equal
        to `M / N` and that the narrower dimension spans from -1 to 1.

    ax : None or matplotlib.axes.Axes or mpl_toolkits.mplot3d.Axes3D, optional
        Axis at which the surface is plotted (default is `None`).  If `None`,
        `matplotlib.pyplot.gca()` is used.

    how : str, optional
        Type of the plot (default is `&#39;contourf&#39;`).  The function is plotted by
        calling `ax.__getattribute__(how)(...)`.

    *args, **kwargs
        Additional arguments passed to `ax.__getattribute__(how)(...)` after the
        first three arguments (`X`, `Y` and `Z` data).

    Returns
    -------
    ax : matplotlib.axes.Axes or mpl_toolkits.mplot3d.Axes3D
        Axis at which the function is plotted.

    Raises
    ------
    TTypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.  If any of the dimensions of
        the array `u` is (strictly) less than 2, an exception of type
        `ValueError` is raised.  If `dom` is an array, it must be sorted
        ascendingly on axis 1 (its rows must be strictly increasing sequences);
        otherwise an exception of type `ValueError` is raised.

    other
        If the command `ax.__getattribute__(how)(X, Y, Z, *args, **kwargs)`
        (where the shapes and values of `X`, `Y` and `Z` are valid if the plot
        type defined by the parameter `how` accepts the same arguments as
        `matplotlib.axes.Axes.contourf`) raises an exception, it is not caught.
        Not even `AttributeError` is caught if `how` is not a valid plot type.

    &#34;&#34;&#34;

    # Sanitise the parameter u.
    if not isinstance(u, _np.ndarray):
        if not (hasattr(u, &#39;__iter__&#39;) or hasattr(u, &#39;__array__&#39;)):
            raise TypeError(&#39;u must be an array.&#39;)
        try:
            u = _np.array(u)
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;u must be an array.&#39;)
    if not issubclass(
        u.dtype.type,
        (_numbers.Real, int, bool, _np.bool, _np.bool_, _np.bool8)
    ):
        raise TypeError(&#39;u must be a real-valued or a boolean array.&#39;)
    if u.ndim != 2:
        raise ValueError(&#39;u must be a matrix (2-dimensional array).&#39;)
    if not u.size:
        raise ValueError(&#39;u must be non-empty.&#39;)
    if u.shape[0] &lt; 2 or u.shape[1] &lt; 2:
        raise ValueError(&#39;Each dimension of u must be at least 2.&#39;)
    if _np.isnan(u).any() or _np.isinf(u).any():
        raise ValueError(&#39;u must not contain NaN or infinite values.&#39;)
    if isinstance(u, _np.matrix):
        u = u.A

    # Sanitise the parameter dom.
    if dom is None:
        dom = _np.array([[-1.0, 1.0], [-1.0, 1.0]], dtype = float, order = &#39;C&#39;)
        if u.shape[0] &gt; u.shape[1]:
            q = float(u.shape[0]) / float(u.shape[1])
            dom[0, 0] = -q
            dom[0, 1] = q
            del q
        elif u.shape[1] &gt; u.shape[0]:
            q = float(u.shape[1]) / float(u.shape[0])
            dom[1, 0] = -q
            dom[1, 1] = q
            del q
    else:
        if not isinstance(dom, _np.ndarray):
            if not (hasattr(dom, &#39;__iter__&#39;) or hasattr(dom, &#39;__array__&#39;)):
                raise TypeError(&#39;Domain must be a numpy array.&#39;)
            try:
                dom = _np.array(dom)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;Domain must be a numpy array.&#39;)
        if not issubclass(dom.dtype.type, _numbers.Real):
            raise TypeError(&#39;Domain must be an real-valued array.&#39;)
        if dom.ndim != 2:
            raise ValueError(&#39;Domain must be a matrix (a 2-dimensional array).&#39;)
        if not dom.shape == (2, 2):
            raise ValueError(&#39;Domain must be a 2 x 2 array.&#39;)
        if _np.isnan(dom).any() or _np.isinf(dom).any():
            raise ValueError(&#39;Domain must not contain NaN or infinite values.&#39;)
        if not (dom[:, 0] &lt; dom[:, 1]).all():
            raise ValueError(&#39;Domain must be sorted ascendingly on axis 1.&#39;)
        if isinstance(dom, _np.matrix):
            dom = dom.A

    # Compute the domain.
    dom = tuple(
        _np.meshgrid(
            _np.linspace(dom[0, 0], dom[0, 1], num = u.shape[0], dtype = float),
            _np.linspace(dom[1, 0], dom[1, 1], num = u.shape[1], dtype = float),
            indexing = &#39;ij&#39;
        )
    )

    # Sanitise the parameter ax.
    if ax is None:
        ax = _plt.gca()
    else:
        if isinstance(ax, _np.ndarray):
            if ax.size == 1:
                ax = ax.ravel()
                ax = ax.dtype.type(ax[0])
        if not isinstance(ax, (_Axes, _Axes3D)):
            raise TypeError(
                &#39;Axis must be of type matplotlib.axes.Axes or &#39;
                &#39;mpl_toolkits.mplot3d.Axes3D.&#39;
            )

    # Sanitise the parameter how.
    if isinstance(how, _np.ndarray):
        if how.size == 1:
            how = how.ravel()
            how = how.dtype.type(how[0])
    if not (
        isinstance(how, _six.string_types) or
        isinstance(how, _six.text_type) or
        isinstance(how, _six.binary_type) or
        isinstance(
            how,
            (
                _np.str,
                _np.str_,
                _np.unicode,
                _np.unicode_,
                _np.string_,
                _np.bytes_
            )
        )
    ):
        raise TypeError(&#39;Plot type must be a string.&#39;)
    try:
        how = _copy.deepcopy(str(how))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Plot type must be of type str.&#39;)

    # Plot the plot.
    ax.__getattribute__(how)(dom[0], dom[1], u, *args, **kwargs)

    # Return the axis.
    return ax</code></pre>
</details>
</dd>
<dt id="script.triang"><code class="name flex">
<span>def <span class="ident">triang</span></span>(<span>x=1, y=None, num=50, return_dom=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the discretisation of a rectangle containing an open triangle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>real</code> <code>in</code> <code>range</code> [<code>0</code>, +<code>inf</code>) or (<code>3</code>,) <code>array_like</code> of <code>reals</code>, optional</dt>
<dd>Width or x-values of the vertices of the triangle (default is 1).
If a
single floating point value is passed, it defines the width of the
triangle.
If an array of three values is passed, each value defines the
x-value of a vertix of the triangle.
Passing a single value <code>x</code> is the
same as passing <code>[-x / 2, x / 2, 0]</code>.
If a single value is passed as
the parameter <code>x</code> and <code>None</code> is passed as <code>y</code>, the value of <code>x</code> does not
affect the resulting rectangle (probably except for extremely large or
extremely small values, and definitely except for zero versus non-zero
values), therefore the parameter <code>x</code> is optional.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>None</code> or <code>real</code> <code>in</code> <code>range</code> [<code>0</code>, +<code>inf</code>) or (<code>3</code>,) <code>array_like</code> of <code>reals</code>, optional</dt>
<dd>Height or y-values of the vertices of the triangle (default is <code>None</code>).
If a single floating point value is passed, it defines the height of the
triangle.
If an array of three values is passed, each value defines the
y-value of a vertix of the triangle.
Passing a single value <code>y</code> is the
same as passing <code>[-y / 2, -y / 2, y / 2]</code>.
If <code>None</code>,
<code>sqrt(0.75) * abs(x[1] - x[0])</code> is used as the height of the triangle.</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code> <code>in</code> <code>range</code> [<code>2</code>, +<code>inf</code>), optional</dt>
<dd>The number of discretisation points used to discretise the wider
dimension of the resulting rectangle (default is 50).</dd>
<dt><strong><code>return_dom</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>If <code>True</code>, the rectangle's boundaries are returned as well as the
rectangle itself (default is <code>False</code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Omega</code></strong> :&ensp;(<code>M</code>, <code>N</code>) <code>array</code> of <code>booleans</code></dt>
<dd>Array of trues and falses representing the discretisation of the
rectangle containing the closure of the triangle.
The rectangle will
span from <code>min(x)</code> to <code>max(x)</code> on its first dimension, and from <code>min(y)</code>
to <code>max(y)</code> on its second dimension, and the equality <code>max(M, N) == num</code>
will be true.
If the ratio
(<code>max(x)</code> - <code>min(x)</code>) / (<code>max(y)</code> - <code>min(y)</code>) (allowing for the
denominator to be equal to 0) cannot be written as a rational number
p / q such that max(p, q) = <code>num</code>, then the narrower dimension of the
rectangle is stretched, possibly resulting in a few additional
rows/columns filled with falses &mdash; this is done so that the
discretisation step is equal on both the x-axis and the y-axis.
The
values of Omega are defined as: <code>Omega[i, j] == True</code> if and only if the
point at the intersection of the <code>i</code>-th discretisation line of the
x-axis and the <code>j</code>-th discretisation line of the y-axis is inside the
open triangle.
Note that the first dimension represents the x-axis.</dd>
<dt><strong><code>dom</code></strong> :&ensp;(<code>2</code>, <code>2</code>) <code>array</code> of <code>floats</code></dt>
<dd>The rectangle that is returned spans from <code>dom[0, 0]</code> to <code>dom[0, 1]</code> on
the x-axis, and from <code>dom[1, 0]</code> to <code>dom[1, 1]</code> on the y-axis.
It is
guarranteed that <code>(dom[:, 0] &lt;= dom[:, 1]).all()</code> is <code>True</code>.
This is
returned only if the parameter <code>return_dom</code> is <code>True</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If any of the parameters is not of a supported type or <code>dtype</code>, an
exception of type <code>TypeError</code> is raised.</dd>
<dt><code>ValueError</code></dt>
<dd>If any of the parameters is not of a supported shape or value, an
exception of type <code>ValueError</code> is raised.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def triang (x = 1, y = None, num = 50, return_dom = False):
    &#34;&#34;&#34;
    Compute the discretisation of a rectangle containing an open triangle.

    Parameters
    ----------
    x : real in range [0, +inf) or (3,) array_like of reals, optional
        Width or x-values of the vertices of the triangle (default is 1).  If a
        single floating point value is passed, it defines the width of the
        triangle.  If an array of three values is passed, each value defines the
        x-value of a vertix of the triangle.  Passing a single value `x` is the
        same as passing `[-x / 2, x / 2, 0]`.  If a single value is passed as
        the parameter `x` and `None` is passed as `y`, the value of `x` does not
        affect the resulting rectangle (probably except for extremely large or
        extremely small values, and definitely except for zero versus non-zero
        values), therefore the parameter `x` is optional.

    y : None or real in range [0, +inf) or (3,) array_like of reals, optional
        Height or y-values of the vertices of the triangle (default is `None`).
        If a single floating point value is passed, it defines the height of the
        triangle.  If an array of three values is passed, each value defines the
        y-value of a vertix of the triangle.  Passing a single value `y` is the
        same as passing `[-y / 2, -y / 2, y / 2]`.  If `None`,
        `sqrt(0.75) * abs(x[1] - x[0])` is used as the height of the triangle.

    num : int in range [2, +inf), optional
        The number of discretisation points used to discretise the wider
        dimension of the resulting rectangle (default is 50).

    return_dom : boolean, optional
        If `True`, the rectangle&#39;s boundaries are returned as well as the
        rectangle itself (default is `False`).

    Returns
    -------
    Omega : (M, N) array of booleans
        Array of trues and falses representing the discretisation of the
        rectangle containing the closure of the triangle.  The rectangle will
        span from `min(x)` to `max(x)` on its first dimension, and from `min(y)`
        to `max(y)` on its second dimension, and the equality `max(M, N) == num`
        will be true.  If the ratio
        (`max(x)` - `min(x)`) / (`max(y)` - `min(y)`) (allowing for the
        denominator to be equal to 0) cannot be written as a rational number
        p / q such that max(p, q) = `num`, then the narrower dimension of the
        rectangle is stretched, possibly resulting in a few additional
        rows/columns filled with falses --- this is done so that the
        discretisation step is equal on both the x-axis and the y-axis.  The
        values of Omega are defined as: `Omega[i, j] == True` if and only if the
        point at the intersection of the `i`-th discretisation line of the
        x-axis and the `j`-th discretisation line of the y-axis is inside the
        open triangle.  Note that the first dimension represents the x-axis.

    dom : (2, 2) array of floats
        The rectangle that is returned spans from `dom[0, 0]` to `dom[0, 1]` on
        the x-axis, and from `dom[1, 0]` to `dom[1, 1]` on the y-axis.  It is
        guarranteed that `(dom[:, 0] &lt;= dom[:, 1]).all()` is `True`.  This is
        returned only if the parameter `return_dom` is `True`.

    Raises
    ------
    TypeError
        If any of the parameters is not of a supported type or `dtype`, an
        exception of type `TypeError` is raised.

    ValueError
        If any of the parameters is not of a supported shape or value, an
        exception of type `ValueError` is raised.

    &#34;&#34;&#34;

    # Define comparison objects used for ordering &lt;, &gt;, &lt;= and &gt;=.
    LT_check = lambda r, s : r &lt; s
    GT_check = lambda r, s : r &gt; s
    LE_check = lambda r, s : r &lt;= s
    GE_check = lambda r, s : r &gt;= s

    # Sanitise the parameter x.
    if isinstance(x, _np.ndarray):
        if x.size == 1:
            x = x.ravel()
            x = x.dtype.type(x[0])
    if hasattr(x, &#39;__iter__&#39;) or hasattr(x, &#39;__array__&#39;):
        if not isinstance(x, _np.ndarray):
            try:
                x = _np.array(x)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;x must be a scalar or an array.&#39;)
        if not issubclass(x.dtype.type, _numbers.Real):
            raise TypeError(&#39;x must be real.&#39;)
        x = x.astype(float)
        if not x.ndim == 1:
            raise ValueError(&#39;x must be a 1-dimensional array.&#39;)
        if not x.size == 3:
            raise ValueError(&#39;x must have exactly 3 elements.&#39;)
    else:
        if not isinstance(x, _numbers.Real):
            raise TypeError(&#39;Width must be real.&#39;)
        try:
            x = _copy.deepcopy(float(x))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;Width must be of type float.&#39;)
        if _math.isnan(x) or _math.isinf(x):
            raise ValueError(&#39;Width must not be NaN or infinite.&#39;)
        if x &lt; 0.0:
            raise ValueError(&#39;Width must not be negative&#39;)
        x = 0.5 * _np.array([-x, x, 0.0], dtype = float, order = &#39;F&#39;)
    if _np.isnan(x).any() or _np.isinf(x).any():
        raise ValueError(&#39;x must be non-NaN and finite.&#39;)
    x[~x.astype(bool)] = 0

    # If y is None, define the heigt of the triangle.
    if y is None:
        y = _math.sqrt(0.75) * abs(float(x[1] - x[0]))

    # Sanitise the parameter y.
    if isinstance(y, _np.ndarray):
        if y.size == 1:
            y = y.ravel()
            y = y.dtype.type(y[0])
    if hasattr(y, &#39;__iter__&#39;) or hasattr(y, &#39;__array__&#39;):
        if not isinstance(y, _np.ndarray):
            try:
                y = _np.array(y)
            except (TypeError, ValueError, AttributeError):
                raise TypeError(&#39;y must be a scalar or an array.&#39;)
        if not issubclass(y.dtype.type, _numbers.Real):
            raise TypeError(&#39;y must be real.&#39;)
        y = y.astype(float)
        if not y.ndim == 1:
            raise ValueError(&#39;y must be a 1-dimensional array.&#39;)
        if not y.size == 3:
            raise ValueError(&#39;y must have exactly 3 elements.&#39;)
    else:
        if not isinstance(y, _numbers.Real):
            raise TypeError(&#39;Height must be real.&#39;)
        try:
            y = _copy.deepcopy(float(y))
        except (TypeError, ValueError, AttributeError):
            raise TypeError(&#39;Height must be of type float.&#39;)
        if _math.isnan(y) or _math.isinf(y):
            raise ValueError(&#39;Height must not be NaN or infinite.&#39;)
        if y &lt; 0.0:
            raise ValueError(&#39;Height must be positive.&#39;)
        y = 0.5 * _np.array([-y, -y, y], dtype = float, order = &#39;F&#39;)
    if _np.isnan(y).any() or _np.isinf(y).any():
        raise ValueError(&#39;y must be non-NaN and finite.&#39;)
    y[~y.astype(bool)] = 0

    # Sanitise the parameter num.
    if isinstance(num, _np.ndarray):
        if num.size == 1:
            num = num.ravel()
            num = num.dtype.type(num[0])
    if not isinstance(num, _numbers.Integral):
        raise TypeError(&#39;Number of discretisation points must be integral.&#39;)
    try:
        num = _copy.deepcopy(int(num))
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Number of discretisation points must be of type int.&#39;)
    if num &lt; 2:
        raise ValueError(
            &#39;Number of discretisation points must be greater than 1.&#39;
        )

    # Sanitise the parameter return_dom.
    if isinstance(return_dom, _np.ndarray):
        if return_dom.size == 1:
            return_dom = return_dom.ravel()
            return_dom = return_dom.dtype.type(return_dom[0])
    if not isinstance(
        return_dom,
        (_numbers.Integral, int, bool, _np.bool, _np.bool8, _np.bool_)
    ):
        raise TypeError(&#39;Parameter return_dom must be boolean.&#39;)
    try:
        if return_dom not in {0, False, 1, True}:
            raise ValueError(&#39;Parameter return_dom must be False or True.&#39;)
    except (TypeError, ValueError, AttributeError):
        raise TypeError(&#39;Parameter return_dom must be False or True.&#39;)
    try:
        return_dom = _copy.deepcopy(bool(return_dom))
    except (TypeError, ValueError, AttributeError):
        raise ValueError(&#39;Parameter return_dom must be of type bool.&#39;)

    # Compute the boundaries and the dimensions of the rectangle.

    x_min = float(x.min())
    x_max = float(x.max())

    y_min = float(y.min())
    y_max = float(y.max())

    a = x_max - x_min
    b = y_max - y_min

    # Initialize the rectangle to all falses.
    Omega = None
    if a &lt; b:
        k = int(_math.ceil(num * a / b))
        a_ = k * b / num
        X = x_min + x_max
        x_min, x_max = ((X - a_) / 2, (X + a_) / 2)
        Omega = _np.zeros((k, num), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del a_
        del X
    elif a &gt; b:
        k = int(_math.ceil(num * b / a))
        b_ = k * a / num
        Y = y_min + y_max
        y_min, y_max = ((Y - b_) / 2, (Y + b_) / 2)
        Omega = _np.zeros((num, k), dtype = _np.bool8, order = &#39;F&#39;)
        del k
        del b_
        del Y
    else:
        Omega = _np.zeros((num, num), dtype = _np.uint8, order = &#39;F&#39;)
    if x_min == 0:
        x_min = 0.0
    if x_max == 0:
        x_max = 0.0
    if y_min == 0:
        y_min = 0.0
    if y_max == 0:
        y_max = 0.0

    # Discretise the rectangle.
    u = _np.linspace(x_min, x_max, num = Omega.shape[0])
    v = _np.linspace(y_min, y_max, num = Omega.shape[1])

    ##  The following code is derived from the formula generating the line
    ##  interpolating two different points on a plane.  For the points
    ##  (x_A, y_A) and (x_B, y_B), if x_B != x_A, the line is generated by the
    ##  explicit formula
    ##      y = (y_B - y_A) / (x_B - x_A) * (x - x_A) + y_A.
    ##  If x_B == x_A, then y_B != y_A (otherwise the points would not be
    ##  different) and the formula could be generated to define x for a fixed
    ##  value of y.  Either way, a point is below/to the left from the line if
    ##  the equality is replaced by &lt;, and above/to the right it if the equality
    ##  is replaced by &gt;.  Then, we multiply the inequality by (x_B - x_A) or
    ##  (y_B - y_A) depending on the case and eventualy get
    ##      (x_B - x_A) * (y - y_A) @ (y_B - y_A) * (x - x_A)
    ##  where @ is the corresponding sign among &lt; and &gt; (opposite the original
    ##  if x_B &lt; x_A).  Knowing the coordinates of the points, the sign can be
    ##  inferred simply by checking which of the two is satisfied.

    # Using the objects LT_check and GT_check, define the comparison objects to
    # check if a point is inside the triangle.
    liner_check = [
        LT_check if LE_check(
            (x[1] - x[0]) * (y[2] - y[0]),
            (y[1] - y[0]) * (x[2] - x[0])
        ) else GT_check,
        LT_check if LE_check(
            (x[2] - x[1]) * (y[0] - y[1]),
            (y[2] - y[1]) * (x[0] - x[1])
        ) else GT_check,
        LT_check if LE_check(
            (x[0] - x[2]) * (y[1] - y[2]),
            (y[0] - y[2]) * (x[1] - x[2])
        ) else GT_check
    ]

    # Compute the values to compare to check if the point is inside the
    # triangle.
    u_liner = _np.array(
        [
            (y[1] - y[0]) * (u - x[0]),
            (y[2] - y[1]) * (u - x[1]),
            (y[0] - y[2]) * (u - x[2])
        ],
        dtype = float,
        order = &#39;F&#39;
    )
    v_liner = _np.array(
        [
            (x[1] - x[0]) * (v - y[0]),
            (x[2] - x[1]) * (v - y[1]),
            (x[0] - x[2]) * (v - y[2])
        ],
        dtype = float,
        order = &#39;F&#39;
    )

    # Fill the rectangle with trues where needed.
    I = list(range(int(u.size)))
    J = list(range(int(v.size)))
    for i in I:
        for j in J:
            Omega[i, j] = _np.bool8(
                liner_check[0](v_liner[0, j], u_liner[0, i]) and
                liner_check[1](v_liner[1, j], u_liner[1, i]) and
                liner_check[2](v_liner[2, j], u_liner[2, i])
            )
        try:
            del j
        except (NameError, UnboundLocalError):
            pass
    try:
        del i
    except (NameError, UnboundLocalError):
        pass
    del I
    del J

    # Free the memory.
    del u_liner
    del v_liner
    del u
    del v

    # Return the rectangle and, if needed, the domain&#39;s boundaries.
    return (
        (
            Omega,
            _np.array(
                [[x_min, x_max], [y_min, y_max]],
                dtype = float,
                order = &#39;F&#39;
            )
        ) if return_dom else Omega
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#dependencies">Dependencies</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="script.eigenfunc" href="#script.eigenfunc">eigenfunc</a></code></li>
<li><code><a title="script.ellips" href="#script.ellips">ellips</a></code></li>
<li><code><a title="script.show_2d_func" href="#script.show_2d_func">show_2d_func</a></code></li>
<li><code><a title="script.triang" href="#script.triang">triang</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>